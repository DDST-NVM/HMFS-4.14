./Documentation/vm/overcommit-accounting:	shmfs memory drawn from the same pool
./Documentation/DocBook/drm.tmpl:          <function>drm_gem_object_init</function> will create an shmfs file of
./Documentation/DocBook/drm.tmpl:          no shmfs backing (called private GEM objects) by initializing them with
./Documentation/DocBook/drm.tmpl:          <function>drm_gem_free_mmap_offset</function>. The shmfs backing store
./Documentation/DocBook/drm.tmpl:          (that function can safely be called if no shmfs backing store has been
./cmake-build-debug/CMakeFiles/clion-log.txt:CMakeLists.txt not found in /Users/Meditator/HMVFS/hmfs
./drivers/gpu/drm/Kconfig:	# we need shmfs for the swappable backing store, and in particular
./drivers/gpu/drm/drm_gem.c: * up at a later date, and as our interface with shmfs for memory allocation.
./drivers/gpu/drm/drm_gem.c: * shmfs backing store.
./drivers/gpu/drm/drm_gem.c: * Allocate a GEM object of the specified size with shmfs backing store
./drivers/gpu/drm/i915/i915_gem.c:	 * To do this we must instruct the shmfs to drop all of its

--kaixin--
./include/uapi/linux/magic.h:#define HMFS_SUPER_MAGIC 	0xABBF 		//hmfs super magic

./include/linux/hugetlb.h:	 * The file will be used as an shm file so shmfs accounting rules
./include/linux/hugetlb.h:	 * The file is being created on the internal vfs mount and shmfs
./mm/mempolicy.c: * For shmfs/tmpfs/hugetlbfs shared memory the policy is shared between
./mm/madvise.c: * NOTE: Currently, only shmfs/tmpfs is supported for this operation.
./mm/nommu.c:		 * if possible - used for chardevs, ramfs/tmpfs/shmfs and
./fs/hmfs/super.c:#include "hmfs_fs.h"
./fs/hmfs/super.c:static struct kmem_cache *hmfs_inode_cachep_;	//inode cachep
./fs/hmfs/super.c:	struct hmfs_inode_info *fi = (struct hmfs_inode_info *)foo;
./fs/hmfs/super.c:static struct inode *hmfs_alloc_inode(struct super_block *sb)
./fs/hmfs/super.c:	struct hmfs_inode_info *fi;
./fs/hmfs/super.c:	fi = (struct hmfs_inode_info *)kmem_cache_alloc(hmfs_inode_cachep,
./fs/hmfs/super.c:static void hmfs_i_callback(struct rcu_head *head)
./fs/hmfs/super.c:	kmem_cache_free(hmfs_inode_cachep, HMFS_I(inode));
./fs/hmfs/super.c:static void hmfs_destroy_inode(struct inode *inode)
./fs/hmfs/super.c:	call_rcu(&inode->i_rcu, hmfs_i_callback);
./fs/hmfs/super.c:int __hmfs_write_inode(struct inode *inode, bool force)
./fs/hmfs/super.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/super.c:		err = sync_hmfs_inode(inode, force);
./fs/hmfs/super.c:		err = sync_hmfs_inode_size(inode, force);
./fs/hmfs/super.c:		err = sync_hmfs_inode_proc(inode, force);
./fs/hmfs/super.c:		hmfs_bug_on(sbi, 1);
./fs/hmfs/super.c:	hmfs_bug_on(sbi, err && err != -ENOSPC);
./fs/hmfs/super.c:static int hmfs_write_inode(struct inode *inode, struct writeback_control *wbc)
./fs/hmfs/super.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/super.c:	return __hmfs_write_inode(inode, false);
./fs/hmfs/super.c:static void hmfs_dirty_inode(struct inode *inode, int flags)
./fs/hmfs/super.c:	struct hmfs_inode_info *hi = HMFS_I(inode);
./fs/hmfs/super.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/super.c:static void hmfs_evict_inode(struct inode *inode)
./fs/hmfs/super.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/super.c:	struct hmfs_node *hi;
./fs/hmfs/super.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/super.c:		hmfs_truncate(inode);
./fs/hmfs/super.c:static void hmfs_put_super(struct super_block *sb)
./fs/hmfs/super.c:	struct hmfs_sb_info *sbi = HMFS_SB(sb);
./fs/hmfs/super.c:	hmfs_destroy_stats(sbi);
./fs/hmfs/super.c:		hmfs_iounmap(sbi->virt_addr);
./fs/hmfs/super.c:	hmfs_dbg("[HMFS] : put super block done!\n");
./fs/hmfs/super.c:static int hmfs_statfs(struct dentry *dentry, struct kstatfs *buf)
./fs/hmfs/super.c:	struct hmfs_sb_info *sbi = HMFS_SB(dentry->d_sb);
./fs/hmfs/super.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/super.c:	hmfs_bug_on(sbi, nr_segment_reserve < 0);
./fs/hmfs/super.c:int hmfs_sync_fs(struct super_block *sb, int sync)
./fs/hmfs/super.c:	struct hmfs_sb_info *sbi = HMFS_SB(sb);
./fs/hmfs/super.c:			ret = hmfs_gc(sbi, FG_GC);
./fs/hmfs/super.c:static int hmfs_freeze(struct super_block *sb)
./fs/hmfs/super.c:	err = hmfs_sync_fs(sb, 1);
./fs/hmfs/super.c:static int hmfs_unfreeze(struct super_block *sb)
./fs/hmfs/super.c:struct super_operations hmfs_sops = {
./fs/hmfs/super.c:	.alloc_inode = hmfs_alloc_inode,
./fs/hmfs/super.c:	.destroy_inode = hmfs_destroy_inode,
./fs/hmfs/super.c:	.write_inode = hmfs_write_inode,
./fs/hmfs/super.c:	.dirty_inode = hmfs_dirty_inode,
./fs/hmfs/super.c:	.evict_inode = hmfs_evict_inode,
./fs/hmfs/super.c:	.put_super = hmfs_put_super,
./fs/hmfs/super.c:	.sync_fs = hmfs_sync_fs,
./fs/hmfs/super.c:	.statfs = hmfs_statfs,
./fs/hmfs/super.c:	.freeze_fs = hmfs_freeze,
./fs/hmfs/super.c:	.unfreeze_fs = hmfs_unfreeze,
./fs/hmfs/super.c:struct dentry *hmfs_mount(struct file_system_type *fs_type, int flags,
./fs/hmfs/super.c:	return mount_nodev(fs_type, flags, data, hmfs_fill_super);
./fs/hmfs/super.c:struct file_system_type hmfs_fs_type = {
./fs/hmfs/super.c:	.name = "hmfs",
./fs/hmfs/super.c:	.mount = hmfs_mount,
./fs/hmfs/super.c:	hmfs_inode_cachep = hmfs_kmem_cache_create("hmfs_inode_cache",
./fs/hmfs/super.c:					      sizeof(struct hmfs_inode_info), NULL);
./fs/hmfs/super.c:	if (hmfs_inode_cachep == NULL)
./fs/hmfs/super.c:	kmem_cache_destroy(hmfs_inode_cachep);
./fs/hmfs/super.c:static void hmfs_check_struct_size(void)
./fs/hmfs/super.c:	BUILD_BUG_ON(sizeof(struct hmfs_super_block) > HMFS_MIN_PAGE_SIZE);
./fs/hmfs/super.c:	BUILD_BUG_ON(sizeof(struct hmfs_inode) > HMFS_MIN_PAGE_SIZE);
./fs/hmfs/super.c:	BUILD_BUG_ON(sizeof(struct hmfs_node) > HMFS_MIN_PAGE_SIZE);
./fs/hmfs/super.c:	BUILD_BUG_ON(sizeof(struct hmfs_nat_node) > HMFS_MIN_PAGE_SIZE);
./fs/hmfs/super.c:	BUILD_BUG_ON(sizeof(struct hmfs_nat_block) > HMFS_MIN_PAGE_SIZE);
./fs/hmfs/super.c:	BUILD_BUG_ON(sizeof(struct hmfs_dentry_block) > HMFS_MIN_PAGE_SIZE);
./fs/hmfs/super.c:	BUILD_BUG_ON(sizeof(struct hmfs_checkpoint) > HMFS_MIN_PAGE_SIZE);
./fs/hmfs/super.c:int init_hmfs(void)
./fs/hmfs/super.c:	hmfs_check_struct_size();
./fs/hmfs/super.c:	err = register_filesystem(&hmfs_fs_type);
./fs/hmfs/super.c:	hmfs_create_root_stat();
./fs/hmfs/super.c:void exit_hmfs(void)
./fs/hmfs/super.c:	hmfs_dbg("[HMFS] : destroy_mmap_struct_cache()\n");
./fs/hmfs/super.c:	hmfs_dbg("[HMFS] : destroy_inodecache()\n");
./fs/hmfs/super.c:	hmfs_dbg("[HMFS] : destroy_node_manager_caches()\n");
./fs/hmfs/super.c:	hmfs_dbg("[HMFS] : destroy_checkpoint_caches()\n");
./fs/hmfs/super.c:	hmfs_dbg("[HMFS] : hmfs_destroy_root_stat()\n");
./fs/hmfs/super.c:	hmfs_destroy_root_stat();
./fs/hmfs/super.c:	hmfs_dbg("[HMFS] : unregister_filesystem()\n");
./fs/hmfs/super.c:	unregister_filesystem(&hmfs_fs_type);
./fs/hmfs/super.c:module_init(init_hmfs);
./fs/hmfs/super.c:module_exit(exit_hmfs);
./fs/hmfs/Makefile.kernel:obj-$(CONFIG_HMFS_FS) += hmfs.o
./fs/hmfs/Makefile.kernel:hmfs-y := super.o node.o inode.o checkpoint.o file.o data.o namei.o segment.o hash.o dir.o symlink.o gc.o recovery.o vmap.o initfs.o util.o proc.o
./fs/hmfs/Makefile.kernel:hmfs-$(CONFIG_HMFS_DEBUG) += debug.o
./fs/hmfs/Makefile.kernel:hmfs-$(CONFIG_HMFS_XATTR) += xattr.o
./fs/hmfs/Makefile.kernel:hmfs-$(CONFIG_HMFS_ACL) += acl.o
./fs/hmfs/initfs.c:#include "hmfs_fs.h"
./fs/hmfs/initfs.c:#include "hmfs.h"
./fs/hmfs/initfs.c:extern struct super_operations hmfs_sops;
./fs/hmfs/initfs.c:static int hmfs_max_page_size_bits(unsigned long long initsize)
./fs/hmfs/initfs.c:static block_t mk_metadata(struct hmfs_sb_info *sbi, block_t *nofs, block_t *dofs)
./fs/hmfs/initfs.c:	sbi->max_page_size_bits = hmfs_max_page_size_bits(initsize);
./fs/hmfs/initfs.c:	area_ofs = sizeof(struct hmfs_super_block);
./fs/hmfs/initfs.c:	ssa_blk_sz = (segment_sz >> HMFS_MIN_PAGE_SIZE_BITS) * sizeof(struct hmfs_summary);
./fs/hmfs/initfs.c:static inline void mk_ssa(struct hmfs_sb_info *sbi, block_t ofs, nid_t nid, uint8_t type)
./fs/hmfs/initfs.c:	struct hmfs_summary *sum = get_summary_by_addr(sbi, ofs);
./fs/hmfs/initfs.c:static block_t mk_root(struct hmfs_sb_info *sbi, block_t *nofs, block_t *dofs)
./fs/hmfs/initfs.c:	struct hmfs_inode *hi = ADDR(sbi, root_ofs);
./fs/hmfs/initfs.c:	struct hmfs_dentry_block *dent_blk;
./fs/hmfs/initfs.c:	hmfs_memcpy(dent_blk->filename[0], ".", 1);
./fs/hmfs/initfs.c:	hmfs_memcpy(dent_blk->filename[1], "..", 2);
./fs/hmfs/initfs.c:static block_t mk_nat(struct hmfs_sb_info *sbi, block_t *nofs, block_t root_ofs)
./fs/hmfs/initfs.c:	struct hmfs_nat_node *nat_root = ADDR(sbi, *nofs);
./fs/hmfs/initfs.c:	struct hmfs_nat_block *nat_data;
./fs/hmfs/initfs.c:	char nat_height = hmfs_get_nat_height(sbi->initsize);
./fs/hmfs/initfs.c:static void init_sit(struct hmfs_sb_info *sbi, block_t nofs, block_t dofs)
./fs/hmfs/initfs.c:	struct hmfs_sit_entry *sit_entry = sbi->sit_entries;
./fs/hmfs/initfs.c:static void init_sb(struct hmfs_sb_info *sbi, uint64_t cp_ofs)
./fs/hmfs/initfs.c:	struct hmfs_super_block *super = ADDR(sbi, 0);
./fs/hmfs/initfs.c:	set_struct(super, nat_height, hmfs_get_nat_height(sbi->initsize));
./fs/hmfs/initfs.c:	sb_checksum = hmfs_make_checksum(super);
./fs/hmfs/initfs.c:	hmfs_memcpy(super, ADDR(sbi, 0), sizeof(struct hmfs_super_block));
./fs/hmfs/initfs.c:static block_t mk_cp(struct hmfs_sb_info *sbi, block_t *nofs, block_t *dofs, block_t nat_ofs)
./fs/hmfs/initfs.c:	struct hmfs_checkpoint *cp = ADDR(sbi, *nofs);
./fs/hmfs/initfs.c:static inline int hmfs_mkfs(struct hmfs_sb_info *sbi)
./fs/hmfs/initfs.c: * hmfs_parse_options - format mount options from string @options to @sbi inner attributes
./fs/hmfs/initfs.c:static int hmfs_parse_options(char *options, struct hmfs_sb_info *sbi, bool remount)
./fs/hmfs/initfs.c:static inline void *hmfs_ioremap(phys_addr_t phys_addr, ssize_t size)
./fs/hmfs/initfs.c:inline int hmfs_iounmap(void *virt_addr)
./fs/hmfs/initfs.c:static int init_map_zero_page(struct hmfs_sb_info *sbi)
./fs/hmfs/initfs.c:inline void destroy_map_zero_page(struct hmfs_sb_info *sbi)
./fs/hmfs/initfs.c:	hmfs_bug_on(sbi, !PageLocked(sbi->map_zero_page));
./fs/hmfs/initfs.c:static struct hmfs_super_block *get_valid_super_block(void *start_addr)
./fs/hmfs/initfs.c:	struct hmfs_super_block *super_1, *super_2;
./fs/hmfs/initfs.c:	checksum_1 = hmfs_make_checksum(super_1);
./fs/hmfs/initfs.c:	checksum_2 = hmfs_make_checksum(super_2);
./fs/hmfs/initfs.c:			hmfs_memcpy(super_2, super_1, sizeof(struct hmfs_super_block));
./fs/hmfs/initfs.c:		hmfs_memcpy(super_1, super_2, sizeof(struct hmfs_super_block));
./fs/hmfs/initfs.c:static struct hmfs_super_block *mount_super_block(struct hmfs_sb_info *sbi)
./fs/hmfs/initfs.c:	struct hmfs_super_block *super;
./fs/hmfs/initfs.c:	sbi->virt_addr = hmfs_ioremap(sbi->phys_addr, sbi->initsize);
./fs/hmfs/initfs.c:		hmfs_iounmap(sbi->virt_addr);
./fs/hmfs/initfs.c:		sbi->virt_addr = hmfs_ioremap(sbi->phys_addr, sbi->initsize);
./fs/hmfs/initfs.c:		hmfs_mkfs(sbi);
./fs/hmfs/initfs.c:		if (!hmfs_readonly(sbi->sb))
./fs/hmfs/initfs.c:static void read_super_block(struct hmfs_sb_info *sbi, struct hmfs_super_block *super)
./fs/hmfs/initfs.c:	sbi->max_page_size_bits = hmfs_max_page_size_bits(sbi->initsize);
./fs/hmfs/initfs.c:	sbi->sb->s_op = &hmfs_sops;
./fs/hmfs/initfs.c:	sbi->sb->s_xattr = hmfs_xattr_handlers;
./fs/hmfs/initfs.c:	sbi->sb->s_maxbytes = hmfs_max_file_size();
./fs/hmfs/initfs.c:static int build_manager(struct hmfs_sb_info *sbi)
./fs/hmfs/initfs.c:	hmfs_bug_on(sbi, sbi->main_addr_end & (SM_I(sbi)->segment_size - 1));
./fs/hmfs/initfs.c:	if (test_opt(sbi, GC) && !hmfs_readonly(sbi->sb)) {
./fs/hmfs/initfs.c:		hmfs_dbg("[HMFS] : GC configed!\n");
./fs/hmfs/initfs.c:	root = hmfs_iget(sbi->sb, HMFS_ROOT_INO);
./fs/hmfs/initfs.c:	retval = hmfs_build_stats(sbi);
./fs/hmfs/initfs.c:static int obtain_init_mm_addr(struct hmfs_sb_info *sbi)
./fs/hmfs/initfs.c:		hmfs_dbg("[HMFS] : Unsuccessful kstrtou64%d,%llx\n",ret,addr);
./fs/hmfs/initfs.c:    hmfs_dbg("[HMFS] : Successful kstrtou64 for init_mm:%llx\n",addr);
./fs/hmfs/initfs.c:	// hmfs_dbg("zero_page:%llx\n",sbi->map_zero_page);
./fs/hmfs/initfs.c:int hmfs_fill_super(struct super_block *sb, void *data, int slient)
./fs/hmfs/initfs.c:	struct hmfs_sb_info *sbi;
./fs/hmfs/initfs.c:	struct hmfs_super_block *super;
./fs/hmfs/initfs.c:	sbi = kzalloc(sizeof(struct hmfs_sb_info), GFP_KERNEL);
./fs/hmfs/initfs.c:	if (hmfs_parse_options((char *)data, sbi, 0)) {
./fs/hmfs/initfs.c:		hmfs_iounmap(sbi->virt_addr);
./fs/hmfs/recovery.c: * fs/hmfs/recovery.c
./fs/hmfs/recovery.c:#include "hmfs.h"
./fs/hmfs/recovery.c:#include "hmfs_fs.h"
./fs/hmfs/recovery.c:static void recovery_data_block(struct hmfs_sb_info *sbi, seg_t src_segno,
./fs/hmfs/recovery.c:				int src_off, struct hmfs_summary *src_sum)
./fs/hmfs/recovery.c:	struct hmfs_node *last = NULL, *this = NULL;
./fs/hmfs/recovery.c:	struct hmfs_summary *par_sum;
./fs/hmfs/recovery.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/recovery.c:				hmfs_memcpy_atomic(&this->i.i_addr[args.ofs_in_node],
./fs/hmfs/recovery.c:				hmfs_memcpy_atomic(&this->dn.addr[args.ofs_in_node],
./fs/hmfs/recovery.c:static void recovery_xdata_block(struct hmfs_sb_info *sbi, seg_t src_segno,
./fs/hmfs/recovery.c:				int src_off, struct hmfs_summary *src_sum)
./fs/hmfs/recovery.c:	struct hmfs_node *last = NULL, *this = NULL;
./fs/hmfs/recovery.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/recovery.c:			hmfs_memcpy_atomic(JUMP(this, x_tag), &arg.src_addr, 8);
./fs/hmfs/recovery.c:static void recovery_node_block(struct hmfs_sb_info *sbi, seg_t src_segno,
./fs/hmfs/recovery.c:			    unsigned int src_off, struct hmfs_summary *src_sum)
./fs/hmfs/recovery.c:	struct hmfs_nat_block *last = NULL, *this = NULL;
./fs/hmfs/recovery.c:			hmfs_memcpy_atomic(&this->entries[args.ofs_in_node].block_addr,
./fs/hmfs/recovery.c:static void recovery_nat_block(struct hmfs_sb_info *sbi, seg_t src_segno, int src_off,
./fs/hmfs/recovery.c:			   struct hmfs_summary *src_sum)
./fs/hmfs/recovery.c:	struct hmfs_checkpoint *hmfs_cp = NULL;
./fs/hmfs/recovery.c:	struct hmfs_nat_node *nat_node = NULL;
./fs/hmfs/recovery.c:		hmfs_bug_on(sbi, !this);
./fs/hmfs/recovery.c:			hmfs_cp = HMFS_CHECKPOINT(this);
./fs/hmfs/recovery.c:			addr_in_par = le64_to_cpu(hmfs_cp->nat_addr);
./fs/hmfs/recovery.c:				hmfs_memcpy_atomic(&hmfs_cp->nat_addr, &args.src_addr, 8);
./fs/hmfs/recovery.c:				hmfs_memcpy_atomic(&nat_node->addr[args.ofs_in_node], 
./fs/hmfs/recovery.c:static void recovery_orphan_block(struct hmfs_sb_info *sbi, seg_t src_segno, 
./fs/hmfs/recovery.c:				int src_off, struct hmfs_summary *src_sum)
./fs/hmfs/recovery.c:	struct hmfs_checkpoint *hmfs_cp;
./fs/hmfs/recovery.c:	hmfs_cp = ADDR(sbi, cp_addr);
./fs/hmfs/recovery.c:	orphan_addr = le64_to_cpu(hmfs_cp->orphan_addrs[get_summary_offset(src_sum)]);
./fs/hmfs/recovery.c:		hmfs_cp->orphan_addrs[get_summary_offset(src_sum)] = 
./fs/hmfs/recovery.c:static void recovery_checkpoint_block(struct hmfs_sb_info *sbi, seg_t src_segno,
./fs/hmfs/recovery.c:				int src_off, struct hmfs_summary *src_sum)
./fs/hmfs/recovery.c:	struct hmfs_checkpoint *prev_cp, *next_cp, *this_cp;
./fs/hmfs/recovery.c:	struct hmfs_summary *dest_sum;
./fs/hmfs/recovery.c:		hmfs_memcpy_atomic(orphan, &cp_addr, 8);
./fs/hmfs/recovery.c:static void recovery_gc_segment(struct hmfs_sb_info *sbi, seg_t segno)
./fs/hmfs/recovery.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/recovery.c:	struct hmfs_summary *sum;
./fs/hmfs/recovery.c:			hmfs_bug_on(sbi, 1);
./fs/hmfs/recovery.c:void recovery_gc_crash(struct hmfs_sb_info *sbi, struct hmfs_checkpoint *hmfs_cp)
./fs/hmfs/recovery.c:	nr_gc_segs = le32_to_cpu(hmfs_cp->nr_gc_segs);
./fs/hmfs/recovery.c:	log_addr = __cal_page_addr(sbi, le32_to_cpu(hmfs_cp->gc_logs), 0);
./fs/hmfs/acl.h:struct hmfs_acl_entry {
./fs/hmfs/acl.h:struct hmfs_acl_entry_short {
./fs/hmfs/acl.h:struct hmfs_acl_header {
./fs/hmfs/acl.h:#define ACL_HEADER(ptr)			((struct hmfs_acl_header *)(ptr))
./fs/hmfs/acl.h:#define ACL_ENTRY(ptr)			((struct hmfs_acl_entry *)(ptr))
./fs/hmfs/acl.h:#define ACL_SHORT_ENTRY_SIZE	sizeof(struct hmfs_acl_entry_short)
./fs/hmfs/acl.h:#define ACL_ENTRY_SIZE			sizeof(struct hmfs_acl_entry)
./fs/hmfs/acl.h:#define ACL_HEADER_SIZE			sizeof(struct hmfs_acl_header)
./fs/hmfs/warp.c:#include "hmfs.h"
./fs/hmfs/warp.c:#include "hmfs_fs.h"
./fs/hmfs/warp.c:struct node_info *hmfs_get_node_info(struct inode *inode, int64_t index) {
./fs/hmfs/warp.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/warp.c:    struct hmfs_nm_info *nm_i = sbi->nm_info;
./fs/hmfs/warp.c:    	// hmfs_dbg("[HMFS] : radix_tree_lookup misses.\n");
./fs/hmfs/warp.c:int warp_clean_up_reading(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/warp.c:// Functionality is moved to hmfs_warp_update()
./fs/hmfs/warp.c:int warp_clean_up_writing(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/warp.c:inline void wake_up_warp(struct hmfs_sb_info *sbi) {
./fs/hmfs/warp.c:		wake_up_process(sbi->warp_thread->hmfs_task);
./fs/hmfs/warp.c:bool warp_is_new_node_info(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/warp.c:int warp_prepare_for_reading(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/warp.c:	struct hmfs_summary *summary = NULL;
./fs/hmfs/warp.c:	// hmfs_dbg("[WARP] prepare reading ino:%d nid:%d index:%llu\n",ni->ino,ni->nid,ni->index);
./fs/hmfs/warp.c:		// hmfs_dbg("[WARP] ERR_WARP_TOO_NEW\n");
./fs/hmfs/warp.c:			// hmfs_dbg("[WARP] prepare reading for nid:%d failed.\n",ni->nid);
./fs/hmfs/warp.c:int warp_prepare_for_writing(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/warp.c:	struct hmfs_summary *summary = NULL;
./fs/hmfs/warp.c:	// hmfs_dbg("[WARP] prepare writing ino:%d nid:%d index:%llu\n",ni->ino,ni->nid,ni->index);
./fs/hmfs/warp.c:		// hmfs_dbg("[WARP] ERR_WARP_TOO_NEW\n");
./fs/hmfs/warp.c:int hmfs_warp_type_range_update(struct file *filp, size_t len, loff_t *ppos, unsigned long type) {
./fs/hmfs/warp.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/warp.c:   	struct hmfs_nm_info *nm_i = sbi->nm_info;
./fs/hmfs/warp.c:	struct hmfs_summary *summary = NULL;
./fs/hmfs/warp.c:		// hmfs_dbg("warp type i:%lli oin:%u\n",i,(unsigned int)di.ofs_in_node);
./fs/hmfs/warp.c:		hmfs_dbg("i:%d nid:%d\n",(int)i,(int)di.nid);
./fs/hmfs/warp.c:				hmfs_dbg("norm nid:%d\n",(int)di.nid);
./fs/hmfs/warp.c:				hmfs_dbg("read nid:%d\n",(int)di.nid);
./fs/hmfs/warp.c:				hmfs_dbg("write nid:%d\n",(int)di.nid);
./fs/hmfs/warp.c:		// hmfs_dbg("Updating %u.\n",di.nid);
./fs/hmfs/warp.c:            // hmfs_dbg("radix_tree_lookup misses.\n");
./fs/hmfs/warp.c:		hmfs_dbg("s%llu,e%llu,this%llu\n",range_start,range_end,range_this);
./fs/hmfs/warp.c:					// hmfs_dbg("warp read i:%llu idx:%llu\n",i,idx);
./fs/hmfs/warp.c:							// hmfs_dbg("add_warp_candidate failed.\n");
./fs/hmfs/warp.c:					// hmfs_dbg("warp write i:%llu idx:%llu\n",i,idx);
./fs/hmfs/warp.c:							// hmfs_dbg("add_warp_candidate failed.\n");
./fs/hmfs/warp.c:    // hmfs_dbg("Dealing with nid:%d [%s]->[%s].\n",nid,cur,nex);
./fs/hmfs/warp.c:int warp_prepare_node_info(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/warp.c:	struct hmfs_summary *summary;
./fs/hmfs/warp.c:	// hmfs_dbg("This %d %d\n", ni->begin_version, sbi->cm_info->new_version);
./fs/hmfs/warp.c:	// hmfs_dbg("[WARP] prepare ino:%d nid:%d type:%d\n",ni->ino,ni->nid,type);
./fs/hmfs/warp.c:int hmfs_warp_update(struct hmfs_sb_info *sbi){
./fs/hmfs/warp.c:    struct hmfs_nm_info *nm_i = sbi->nm_info;
./fs/hmfs/warp.c:	// struct hmfs_node *hn;
./fs/hmfs/warp.c:	struct hmfs_summary *summary = NULL;
./fs/hmfs/warp.c:        // hmfs_dbg("Dealing with nid:%d\n",le->nip->nid);
./fs/hmfs/warp.c:				// hmfs_dbg("[WARP] : normal update nid:%u\n",ni->nid);
./fs/hmfs/warp.c:				// hmfs_dbg("bt:%04X\n",le16_to_cpu(summary->bt));
./fs/hmfs/warp.c:				// hmfs_dbg("[WARP] : read update nid:%u\n",ni->nid);
./fs/hmfs/warp.c:                // if (get_warp_read_pure(summary)) hmfs_dbg("pure_read\n");
./fs/hmfs/warp.c:				// else hmfs_dbg("not_pure_read\n");
./fs/hmfs/warp.c:				// hmfs_dbg("[WARP] : write update nid:%u\n",ni->nid);
./fs/hmfs/warp.c:				// hmfs_dbg("[WARP] : hybrid update nid:%u\n",ni->nid);
./fs/hmfs/warp.c:		// hmfs_dbg("nid:%u complete1.\n",ni->nid);
./fs/hmfs/warp.c:		// hmfs_dbg("nid:%u complete2.\n",ni->nid);
./fs/hmfs/warp.c:	// hmfs_dbg("hmfs_warp_update complete.\n");
./fs/hmfs/warp.c:struct node_info *find_next_warp_inter(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/warp.c:	struct hmfs_nm_info *nm_i = sbi->nm_info;
./fs/hmfs/warp.c:	// struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/warp.c:	//struct hmfs_proc_info *proc = radix_tree_lookup(&nm_i->p_ino_root,ni->ino);
./fs/hmfs/warp.c:	struct hmfs_proc_info *proc = NULL;
./fs/hmfs/warp.c:	inode = hmfs_iget(sbi->sb, ni->ino);
./fs/hmfs/warp.c:	// hmfs_dbg("search nid %lu ino %lu\n", (unsigned long) ni->nid, (unsigned long) ni->ino);
./fs/hmfs/warp.c:	// if (ret!=NULL) hmfs_dbg("This is %lu, next is %lu\n", (unsigned long) ni->nid ,(unsigned long) ret->nid);
./fs/hmfs/warp.c:inline struct node_info *find_next_warp_inner(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/warp.c:int warp_deal_with_pending(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/warp.c:	struct hmfs_sb_info *sbi = data;
./fs/hmfs/warp.c:        // hmfs_dbg("warp_function: A %d times\n", ++time_count);  
./fs/hmfs/warp.c:		// hmfs_dbg("[warping] warp_thread_func\n");
./fs/hmfs/warp.c:        // hmfs_dbg("warp_function: B %d times\n", ++time_count);  
./fs/hmfs/warp.c:			// hmfs_dbg("[warping] In\n");
./fs/hmfs/warp.c:        // hmfs_dbg("warp_function: C %d times\n", ++time_count);  
./fs/hmfs/warp.c:int start_warp_thread(struct hmfs_sb_info *sbi) {
./fs/hmfs/warp.c:	struct hmfs_kthread *warp_thread = NULL;
./fs/hmfs/warp.c:	warp_thread = kmalloc(sizeof(struct hmfs_kthread), GFP_KERNEL);
./fs/hmfs/warp.c:	warp_thread->hmfs_task = kthread_run(warp_thread_func, sbi, "HMFS_warp");
./fs/hmfs/warp.c:	if (IS_ERR(warp_thread->hmfs_task)) {
./fs/hmfs/warp.c:		err = PTR_ERR(warp_thread->hmfs_task);
./fs/hmfs/warp.c:void stop_warp_thread(struct hmfs_sb_info *sbi) {
./fs/hmfs/warp.c:		kthread_stop(sbi->warp_thread->hmfs_task);
./fs/hmfs/warp.c:		hmfs_bug_on(sbi, !list_empty(&sbi->nm_info->warp_pending_list));
./fs/hmfs/xattr.c: * fs/hmfs/xattr.c
./fs/hmfs/xattr.c:#include "hmfs.h"
./fs/hmfs/xattr.c:#include "hmfs_fs.h"
./fs/hmfs/xattr.c:static const struct xattr_handler *hmfs_xattr_handler_map[];
./fs/hmfs/xattr.c:static struct hmfs_xattr_entry *__find_xattr(void *base_addr, int index,
./fs/hmfs/xattr.c:	struct hmfs_xattr_entry *entry;
./fs/hmfs/xattr.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/xattr.c:	struct hmfs_inode *inode_block;
./fs/hmfs/xattr.c:static size_t hmfs_xattr_generic_list(struct dentry *dentry, char *list,
./fs/hmfs/xattr.c:	struct hmfs_sb_info *sbi = HMFS_SB(dentry->d_sb);
./fs/hmfs/xattr.c:	handler = hmfs_xattr_handler_map[flags];
./fs/hmfs/xattr.c:static int __hmfs_getxattr(struct inode *inode, int index, const char *name,
./fs/hmfs/xattr.c:	struct hmfs_xattr_entry *entry;
./fs/hmfs/xattr.c:int hmfs_getxattr(struct inode *inode, int index, const char *name,
./fs/hmfs/xattr.c:	ret = __hmfs_getxattr(inode, index, name, buffer, buffer_size);
./fs/hmfs/xattr.c:static int hmfs_xattr_generic_get(struct dentry *dentry, const char *name,
./fs/hmfs/xattr.c:	struct hmfs_sb_info *sbi = HMFS_SB(dentry->d_sb);
./fs/hmfs/xattr.c:	return hmfs_getxattr(dentry->d_inode, flags, name,
./fs/hmfs/xattr.c:static int __hmfs_setxattr(struct inode *inode, int index,
./fs/hmfs/xattr.c:	struct hmfs_xattr_entry *this, *last, *next;
./fs/hmfs/xattr.c:		/* Add another hmfs_xattr_entry for end entry */
./fs/hmfs/xattr.c:		hmfs_memcpy(XATTR_FIRST_ENTRY(new_xattr_blk), next, cpy_size);
./fs/hmfs/xattr.c:		hmfs_memcpy(next, XATTR_NEXT_ENTRY(this), cpy_size);
./fs/hmfs/xattr.c:	hmfs_bug_on(HMFS_I_SB(inode), DISTANCE(new_xattr_blk, 
./fs/hmfs/xattr.c:static int hmfs_setxattr(struct inode *inode, int index, const char *name,
./fs/hmfs/xattr.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/xattr.c:	err = __hmfs_setxattr(inode, index, name, value, size, flags);
./fs/hmfs/xattr.c:static int hmfs_xattr_generic_set(struct dentry *dentry, const char *name,
./fs/hmfs/xattr.c:	struct hmfs_sb_info *sbi = HMFS_SB(dentry->d_sb);
./fs/hmfs/xattr.c:	return hmfs_setxattr(dentry->d_inode, handler_flags, name,
./fs/hmfs/xattr.c:static size_t hmfs_xattr_advise_list(struct dentry *dentry, char *list,
./fs/hmfs/xattr.c:static int hmfs_xattr_advise_get(struct dentry *dentry, const char *name,
./fs/hmfs/xattr.c:static int hmfs_xattr_advise_set(struct dentry *dentry, const char *name,
./fs/hmfs/xattr.c:static int hmfs_initxattrs(struct inode *inode, const struct xattr *xattr_array,
./fs/hmfs/xattr.c:		err = hmfs_setxattr(inode, HMFS_XATTR_INDEX_SECURITY,
./fs/hmfs/xattr.c:int hmfs_init_security(struct inode *inode ,struct inode *dir,
./fs/hmfs/xattr.c:				&hmfs_initxattrs, ipage);
./fs/hmfs/xattr.c:const struct xattr_handler hmfs_xattr_trusted_handler = {
./fs/hmfs/xattr.c:	.list = hmfs_xattr_generic_list,
./fs/hmfs/xattr.c:	.get = hmfs_xattr_generic_get,
./fs/hmfs/xattr.c:	.set = hmfs_xattr_generic_set,
./fs/hmfs/xattr.c:const struct xattr_handler hmfs_xattr_advise_handler = {
./fs/hmfs/xattr.c:	.list = hmfs_xattr_advise_list,
./fs/hmfs/xattr.c:	.get = hmfs_xattr_advise_get,
./fs/hmfs/xattr.c:	.set = hmfs_xattr_advise_set,
./fs/hmfs/xattr.c:const struct xattr_handler hmfs_xattr_security_handler = {
./fs/hmfs/xattr.c:	.list = hmfs_xattr_generic_list,
./fs/hmfs/xattr.c:	.get = hmfs_xattr_generic_get,
./fs/hmfs/xattr.c:	.set = hmfs_xattr_generic_set,
./fs/hmfs/xattr.c:const struct xattr_handler hmfs_xattr_user_handler = {
./fs/hmfs/xattr.c:	.list = hmfs_xattr_generic_list,
./fs/hmfs/xattr.c:	.get = hmfs_xattr_generic_get,
./fs/hmfs/xattr.c:	.set = hmfs_xattr_generic_set,
./fs/hmfs/xattr.c:static const struct xattr_handler *hmfs_xattr_handler_map[] = {
./fs/hmfs/xattr.c:	[HMFS_XATTR_INDEX_USER] = &hmfs_xattr_user_handler,
./fs/hmfs/xattr.c:	[HMFS_XATTR_INDEX_POSIX_ACL_ACCESS] = &hmfs_acl_access_handler,
./fs/hmfs/xattr.c:	[HMFS_XATTR_INDEX_POSIX_ACL_DEFAULT] = &hmfs_acl_default_handler,
./fs/hmfs/xattr.c:	[HMFS_XATTR_INDEX_TRUSTED] = &hmfs_xattr_trusted_handler,
./fs/hmfs/xattr.c:	[HMFS_XATTR_INDEX_SECURITY] = &hmfs_xattr_security_handler,
./fs/hmfs/xattr.c:	[HMFS_XATTR_INDEX_ADVISE] = &hmfs_xattr_advise_handler,
./fs/hmfs/xattr.c:const struct xattr_handler *hmfs_xattr_handlers[] = {
./fs/hmfs/xattr.c:	&hmfs_xattr_user_handler,
./fs/hmfs/xattr.c:	&hmfs_xattr_trusted_handler,
./fs/hmfs/xattr.c:	&hmfs_xattr_advise_handler,
./fs/hmfs/xattr.c:	&hmfs_xattr_security_handler,
./fs/hmfs/xattr.c:	&hmfs_acl_access_handler,
./fs/hmfs/xattr.c:	&hmfs_acl_default_handler,
./fs/hmfs/xattr.c:static inline const struct xattr_handler *hmfs_xattr_handler(int index)
./fs/hmfs/xattr.c:	if (index > 0 && index < ARRAY_SIZE(hmfs_xattr_handler_map))
./fs/hmfs/xattr.c:		handler = hmfs_xattr_handler_map[index];
./fs/hmfs/xattr.c:ssize_t hmfs_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)
./fs/hmfs/xattr.c:	struct hmfs_xattr_entry *entry;
./fs/hmfs/xattr.c:				hmfs_xattr_handler(entry->e_name_index);
./fs/hmfs/segment.h:#include "hmfs.h"
./fs/hmfs/segment.h:#define hmfs_bitmap_size(nr)			\
./fs/hmfs/segment.h:#define LOGS_ENTRY_PER_SEG(sbi)	(SM_I(sbi)->segment_size / sizeof(struct hmfs_sit_log_entry))
./fs/hmfs/segment.h:struct hmfs_sm_info {
./fs/hmfs/segment.h:static inline struct hmfs_sm_info *SM_I(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.h:static inline struct sit_info *SIT_I(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.h:static inline struct seg_entry *get_seg_entry(struct hmfs_sb_info *sbi, seg_t segno)
./fs/hmfs/segment.h:static inline unsigned int get_valid_blocks(struct hmfs_sb_info *sbi, seg_t segno)
./fs/hmfs/segment.h:static inline struct hmfs_sit_entry *get_sit_entry(struct hmfs_sb_info *sbi,
./fs/hmfs/segment.h:static inline struct allocator *ALLOCATOR(struct hmfs_sb_info *sbi, int i)
./fs/hmfs/segment.h:static inline struct free_segmap_info *FREE_I(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.h:static inline struct dirty_seglist_info *DIRTY_I(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.h:static inline bool is_new_block(struct hmfs_sb_info *sbi, block_t addr) {
./fs/hmfs/segment.h:	struct hmfs_summary *sum = get_summary_by_addr(sbi, addr);
./fs/hmfs/segment.h:static inline unsigned long GET_SEGNO(struct hmfs_sb_info *sbi, block_t addr)
./fs/hmfs/segment.h:static inline unsigned int GET_SEG_OFS(struct hmfs_sb_info *sbi, block_t addr)
./fs/hmfs/segment.h:static inline pgc_t overprovision_segments(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.h:static inline pgc_t free_segments(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.h:static inline pgc_t free_user_blocks(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.h:static inline bool has_enough_invalid_blocks(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.h:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/segment.h:	struct hmfs_sm_info *sm_i = SM_I(sbi);
./fs/hmfs/segment.h:	hmfs_bug_on(sbi, cm_i->alloc_block_count < cm_i->valid_block_count);
./fs/hmfs/segment.h:static inline bool has_not_enough_free_segs(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.h:static inline unsigned long long get_mtime(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.h:					 struct hmfs_sit_entry *raw_entry)
./fs/hmfs/segment.h:				       struct hmfs_sit_entry *raw_entry)
./fs/hmfs/segment.h:static inline void __set_inuse(struct hmfs_sb_info *sbi, seg_t segno)
./fs/hmfs/util.c:#include "hmfs.h"
./fs/hmfs/util.c:pte_t * (*hmfs_get_locked_pte) (struct mm_struct *, unsigned long, 
./fs/hmfs/util.c:	hmfs_get_locked_pte = 
./fs/hmfs/test/create1.sh:DIR="/home/goku/mnt-hmfs/"	#Mount ppoint of tested HMFS instance
./fs/hmfs/test/cp2.sh:DIR="/home/goku/mnt-hmfs"	#Mount ppoint of tested HMFS instance
./fs/hmfs/test/cp1.sh:DIR="/home/goku/mnt-hmfs"	#Mount ppoint of tested HMFS instance
./fs/hmfs/test/cp1.sh:MODULE="hmfs"				#Name of compiled HMFS module
./fs/hmfs/test/cp1.sh:CONTENT="/home/goku/workspace/hmfs/fs/hmfs/test/content" #Path of content which is source of text for testing
./fs/hmfs/test/cp1.sh:mount -t hmfs -o physaddr=$PHYSADDR,init=$INITSIZE none $DIR
./fs/hmfs/test/cp1.sh:cd /sys/kernel/debug/hmfs/4294967296/
./fs/hmfs/test/cp1.sh:mount -t hmfs -o physaddr=$PHYSADDR,ro,mnt_cp=$internal none $DIR
./fs/hmfs/test/cp1.sh:mount -t hmfs -o physaddr=$PHYSADDR none $DIR
./fs/hmfs/test/cp1.sh:cd /sys/kernel/debug/hmfs/4294967296/
./fs/hmfs/test/cp1.sh:mount -t hmfs -o physaddr=$PHYSADDR none $DIR
./fs/hmfs/test_cheng/link_unlink.sh:WORK_DIR="/home/weiyu/mnt-hmfs/"
Binary file ./fs/hmfs/test_cheng/write matches
./fs/hmfs/test_cheng/mkdir.sh:WORK_DIR="/home/weiyu/mnt-hmfs/"
./fs/hmfs/test_cheng/show_version.sh:WORK_DIR="/home/weiyu/mnt-hmfs/"
./fs/hmfs/test_cheng/show_version.sh:DEBUG_DIR="/sys/kernel/debug/hmfs/1073741824"
./fs/hmfs/test_cheng/map_unmap.c:#define WORK_DIR "/home/weiyu/mnt-hmfs/"
./fs/hmfs/test_cheng/mount.sh:WORK_DIR="/home/weiyu/mnt-hmfs/"
./fs/hmfs/test_cheng/mount.sh:echo $password | sudo mount -t hmfs -o physaddr=0x40000000,init=2G,gid=1000,uid=1000 none $WORK_DIR
./fs/hmfs/test_cheng/mount.sh:mount | grep hmfs
Binary file ./fs/hmfs/test_cheng/read matches
./fs/hmfs/test_cheng/read.c:#define WORK_DIR "/home/weiyu/mnt-hmfs/"
Binary file ./fs/hmfs/test_cheng/open_close matches
./fs/hmfs/test_cheng/umount.sh:WORK_DIR="/home/weiyu/mnt-hmfs/"
./fs/hmfs/test_cheng/umount.sh:mount | grep hmfs
Binary file ./fs/hmfs/test_cheng/map_unmap matches
./fs/hmfs/test_cheng/delete_cp.sh:WORK_DIR="/home/weiyu/mnt-hmfs/"
./fs/hmfs/test_cheng/delete_cp.sh:DEBUG_DIR="/sys/kernel/debug/hmfs/1073741824"
./fs/hmfs/test_cheng/delete.sh:WORK_DIR="/home/weiyu/mnt-hmfs/"
./fs/hmfs/test_cheng/clear.sh:WORK_DIR="/home/weiyu/mnt-hmfs/"
./fs/hmfs/test_cheng/symlink.sh:WORK_DIR="/home/weiyu/mnt-hmfs/"
./fs/hmfs/test_cheng/create.sh:WORK_DIR="/home/weiyu/mnt-hmfs/"
./fs/hmfs/test_cheng/rename.sh:WORK_DIR="/home/weiyu/mnt-hmfs/"
Binary file ./fs/hmfs/test_cheng/make_cp matches
./fs/hmfs/test_cheng/make_cp.c:#define WORK_DIR "/home/weiyu/mnt-hmfs/"
./fs/hmfs/test_cheng/open_close.c:#define WORK_DIR "/home/weiyu/mnt-hmfs/"
./fs/hmfs/test_cheng/write.c:#define WORK_DIR "/home/weiyu/mnt-hmfs/"
./fs/hmfs/test_cheng/read_compare.sh:WORK_DIR="/home/weiyu/mnt-hmfs/"
./fs/hmfs/test_cheng/rmdir.sh:WORK_DIR="/home/weiyu/mnt-hmfs/"
./fs/hmfs/billy.mk:hmfs_300M_2G:
./fs/hmfs/billy.mk:	sudo mount -t hmfs -o physaddr=0x80000000,uid=1000,gid=1000,init=140M none ~/hmfsMount/
./fs/hmfs/billy.mk:hmfs_300M_2G_deep:
./fs/hmfs/billy.mk:	sudo mount -t hmfs -o physaddr=0x80000000,uid=1000,gid=1000,init=140M,deep_fmt=1 none ~/hmfsMount/
./fs/hmfs/billy.mk:hmfs_300M_2G_remount:
./fs/hmfs/billy.mk:	sudo mount -t hmfs -o physaddr=0x80000000,uid=1000,gid=1000 none ~/hmfsMount/
./fs/hmfs/billy.mk:hmfs_1G_2G:
./fs/hmfs/billy.mk:	sudo mount -t hmfs -o physaddr=0x80000000,uid=1000,gid=1000,init=1G none ~/hmfsMount/
./fs/hmfs/billy.mk:ins_hmfs:
./fs/hmfs/billy.mk:	sudo insmod ./hmfs.ko 
./fs/hmfs/billy.mk:rm_hmfs:
./fs/hmfs/billy.mk:	sudo rmmod hmfs
./fs/hmfs/billy.mk:mount_hmfs:
./fs/hmfs/billy.mk:	sudo mount -t hmfs -o physaddr=0xc0000000,init=40M none ~/hmfsMount/
./fs/hmfs/billy.mk:hmfs:
./fs/hmfs/billy.mk:	sudo insmod ./hmfs.ko && sudo mount -t hmfs -o physaddr=0xc0000000,init=40M none ~/hmfsMount/
./fs/hmfs/billy.mk:nohmfs:
./fs/hmfs/billy.mk:	sudo umount ~/hmfsMount && sudo rmmod hmfs
./fs/hmfs/Makefile:obj-$(CONFIG_HMFS_FS) += hmfs.o
./fs/hmfs/Makefile:hmfs-y := super.o node.o inode.o checkpoint.o file.o data.o namei.o segment.o hash.o dir.o symlink.o gc.o recovery.o vmap.o initfs.o util.o proc.o
./fs/hmfs/Makefile:hmfs-$(CONFIG_HMFS_DEBUG) += debug.o
./fs/hmfs/Makefile:hmfs-$(CONFIG_HMFS_XATTR) += xattr.o
./fs/hmfs/Makefile:hmfs-$(CONFIG_HMFS_ACL) += acl.o
./fs/hmfs/Kconfig:	  /sys/kernel/debug/hmfs/status includes:
./fs/hmfs/gc.h:#include "hmfs.h"
./fs/hmfs/gc.h:#include "hmfs_fs.h"
./fs/hmfs/gc.h:	struct hmfs_summary *dest_sum, *parent_sum, *src_sum;
./fs/hmfs/gc.h:void prepare_move_argument(struct gc_move_arg *arg, struct hmfs_sb_info *sbi, seg_t mv_segno,
./fs/hmfs/gc.h:static inline bool need_deep_scan(struct hmfs_sb_info *sbi, uint8_t gc_mode)
./fs/hmfs/gc.h:static inline bool need_more_scan(struct hmfs_sb_info *sbi, seg_t segno, 
./fs/hmfs/gc.h:static inline long increase_sleep_time(struct hmfs_sb_info *sbi, long wait)
./fs/hmfs/gc.h:static inline long decrease_sleep_time(struct hmfs_sb_info *sbi, long wait)
./fs/hmfs/gc.h:static inline ver_t find_first_valid_version(struct hmfs_summary *sum, uint8_t seg_type)
./fs/hmfs/node.h:#include "hmfs.h"
./fs/hmfs/node.h:#include "hmfs_fs.h"
./fs/hmfs/node.h:static inline void set_node_info_this_version(struct hmfs_sb_info *sbi, struct node_info *ni){
./fs/hmfs/node.h:					struct hmfs_nat_entry *ne)
./fs/hmfs/node.h:static inline void node_info_from_raw_nat(struct hmfs_sb_info *sbi, struct node_info *ni,
./fs/hmfs/node.h:					  struct hmfs_nat_entry *ne)
./fs/hmfs/node.h:	// hmfs_dbg("That %d %d\n", ni->begin_version, sbi->cm_info->new_version);
./fs/hmfs/node.h:static inline char hmfs_get_nat_height(unsigned long long initsize)
./fs/hmfs/Makefile.goku:obj-m += hmfs.o
./fs/hmfs/Makefile.goku:hmfs-objs := super.o node.o inode.o checkpoint.o file.o data.o namei.o segment.o hash.o dir.o symlink.o gc.o recovery.o vmap.o warp.o initfs.o util.o proc.o
./fs/hmfs/Makefile.goku:hmfs-objs += debug.o
./fs/hmfs/Makefile.goku:hmfs-objs += xattr.o
./fs/hmfs/Makefile.goku:hmfs-objs += acl.o
./fs/hmfs/hash.c:#include "hmfs.h"
./fs/hmfs/hash.c:#include "hmfs_fs.h"
./fs/hmfs/hash.c:hmfs_hash_t hmfs_dentry_hash(const struct qstr *name_info)
./fs/hmfs/hash.c:	hmfs_hash_t hmfs_hash;
./fs/hmfs/hash.c:	hmfs_hash = cpu_to_le32(hash & ~HMFS_HASH_COL_BIT);
./fs/hmfs/hash.c:	return hmfs_hash;
./fs/hmfs/dir.c: * fs/hmfs/dir.c
./fs/hmfs/dir.c:#include "hmfs_fs.h"
./fs/hmfs/dir.c:#include "hmfs.h"
./fs/hmfs/dir.c:unsigned char hmfs_filetype_table[HMFS_FT_MAX] = {
./fs/hmfs/dir.c:static unsigned char hmfs_type_by_mode[S_IFMT >> S_SHIFT] = {
./fs/hmfs/dir.c:static inline void set_de_type(struct hmfs_dir_entry *de, umode_t mode)
./fs/hmfs/dir.c:	de->file_type = hmfs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];
./fs/hmfs/dir.c: * Return a hmfs_dentry_block for writing. We should not call
./fs/hmfs/dir.c:struct hmfs_dentry_block *get_dentry_block_for_write(struct inode *dir,	int old_bidx)
./fs/hmfs/dir.c:	struct hmfs_inode *inode_block;
./fs/hmfs/dir.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(dir);
./fs/hmfs/dir.c:		hmfs_bug_on(sbi, old_bidx > 0);
./fs/hmfs/dir.c:static bool early_match_name(size_t namelen, hmfs_hash_t namehash,
./fs/hmfs/dir.c:				struct hmfs_dir_entry *de)
./fs/hmfs/dir.c:static struct hmfs_dir_entry *find_target_dentry(struct qstr *name, 
./fs/hmfs/dir.c:				int *max_slots, struct hmfs_dentry_ptr *d)
./fs/hmfs/dir.c:	struct hmfs_dir_entry *de;
./fs/hmfs/dir.c:	hmfs_hash_t namehash = hmfs_dentry_hash(name);
./fs/hmfs/dir.c: * @dentry_blk: pointer to hmfs_dentry_block
./fs/hmfs/dir.c:static struct hmfs_dir_entry *find_in_block(struct hmfs_dentry_block *dentry_blk,
./fs/hmfs/dir.c:	struct hmfs_dir_entry *de;
./fs/hmfs/dir.c:	struct hmfs_dentry_ptr d;
./fs/hmfs/dir.c:static struct hmfs_dir_entry *find_in_level(struct inode *dir, unsigned int level,
./fs/hmfs/dir.c:				struct qstr *name, hmfs_hash_t namehash, int *res_bidx, int *ofs_in_blk)
./fs/hmfs/dir.c:	struct hmfs_dir_entry *de = NULL;
./fs/hmfs/dir.c:	struct hmfs_dentry_block *dentry_blk = NULL;
./fs/hmfs/dir.c:struct hmfs_dir_entry *hmfs_find_entry(struct inode *dir, struct qstr *child,
./fs/hmfs/dir.c:	struct hmfs_dir_entry *de = NULL;
./fs/hmfs/dir.c:	hmfs_hash_t name_hash = 0;
./fs/hmfs/dir.c:	struct hmfs_inode *inode_block;
./fs/hmfs/dir.c:	struct hmfs_dentry_block *dentry_blk;
./fs/hmfs/dir.c:	name_hash = hmfs_dentry_hash(child);
./fs/hmfs/dir.c:struct hmfs_dir_entry *hmfs_parent_dir(struct inode *dir)
./fs/hmfs/dir.c:	struct hmfs_dir_entry *de = NULL;
./fs/hmfs/dir.c:	struct hmfs_dentry_block *dentry_blk = NULL;
./fs/hmfs/dir.c:void hmfs_set_link(struct inode *dir, struct hmfs_dir_entry *de,
./fs/hmfs/dir.c:static void init_dent_inode(const struct qstr *name, struct hmfs_inode *hi)
./fs/hmfs/dir.c:	struct hmfs_sb_info *sbi = HMFS_SB(sb);
./fs/hmfs/dir.c:	struct hmfs_node *hn;
./fs/hmfs/dir.c:				struct hmfs_dentry_ptr *d)
./fs/hmfs/dir.c:	struct hmfs_dir_entry *de;
./fs/hmfs/dir.c:				struct hmfs_node *hn)
./fs/hmfs/dir.c:	struct hmfs_dentry_block *dentry_blk = NULL;
./fs/hmfs/dir.c:	struct hmfs_dentry_ptr d;
./fs/hmfs/dir.c:static struct hmfs_node *init_inode_metadata(struct inode *inode, struct inode *dir,
./fs/hmfs/dir.c:	struct hmfs_sb_info *sbi = HMFS_SB(sb);
./fs/hmfs/dir.c:	struct hmfs_node *hn = NULL;
./fs/hmfs/dir.c:		err = hmfs_init_acl(inode, dir);
./fs/hmfs/dir.c:	/* For newly created directory, FI_INC_LINK is set in hmfs_new_inode */
./fs/hmfs/dir.c:static void hmfs_update_dentry(nid_t ino, umode_t mode, struct hmfs_dentry_ptr *d,
./fs/hmfs/dir.c:				const struct qstr *name, hmfs_hash_t name_hash,	unsigned int bit_pos)
./fs/hmfs/dir.c:	struct hmfs_dir_entry *de;
./fs/hmfs/dir.c:int __hmfs_add_link(struct inode *dir, const struct qstr *name, struct inode *inode)
./fs/hmfs/dir.c:	hmfs_hash_t dentry_hash = 0;
./fs/hmfs/dir.c:	struct hmfs_dentry_block *dentry_blk = NULL;
./fs/hmfs/dir.c:	struct hmfs_dentry_ptr d;
./fs/hmfs/dir.c:	struct hmfs_node *hn;
./fs/hmfs/dir.c:	struct hmfs_inode *inode_block;
./fs/hmfs/dir.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/dir.c:	dentry_hash = hmfs_dentry_hash(name);
./fs/hmfs/dir.c:			err = hmfs_convert_inline_inode(dir);
./fs/hmfs/dir.c:	hmfs_update_dentry(inode->i_ino, inode->i_mode, &d, name, dentry_hash, bit_pos);
./fs/hmfs/dir.c:void hmfs_drop_nlink(struct inode *dir, struct inode *inode, struct page *page)
./fs/hmfs/dir.c:void hmfs_delete_entry(struct hmfs_dir_entry *dentry, struct hmfs_dentry_block *dentry_blk,
./fs/hmfs/dir.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(dir);
./fs/hmfs/dir.c:		hmfs_bug_on(sbi, is_inline_inode(dir));
./fs/hmfs/dir.c:			dir_i_size = hmfs_dir_seek_data_reverse(dir, bidx + 1)
./fs/hmfs/dir.c:bool hmfs_empty_dir(struct inode *dir)
./fs/hmfs/dir.c:	struct hmfs_dentry_block *dentry_blk;
./fs/hmfs/dir.c:	struct hmfs_inode *inode_block;
./fs/hmfs/dir.c:			hmfs_bug_on(HMFS_I_SB(dir), bidx == 0);
./fs/hmfs/dir.c:static bool hmfs_fill_dentries(struct hmfs_sb_info *sbi, struct dir_context *ctx, 
./fs/hmfs/dir.c:				struct hmfs_dentry_ptr *d, unsigned int start_pos)
./fs/hmfs/dir.c:	struct hmfs_dir_entry *de = NULL;
./fs/hmfs/dir.c:			d_type = hmfs_filetype_table[de->file_type];
./fs/hmfs/dir.c:		hmfs_bug_on(sbi, !le16_to_cpu(de->name_len));
./fs/hmfs/dir.c:static int hmfs_readdir(struct file *file, struct dir_context *ctx)
./fs/hmfs/dir.c:	struct hmfs_dentry_block *dentry_blk = NULL;
./fs/hmfs/dir.c:	struct hmfs_inode *inode_block;
./fs/hmfs/dir.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/dir.c:	struct hmfs_dentry_ptr d;
./fs/hmfs/dir.c:		if (hmfs_fill_dentries(HMFS_I_SB(inode), ctx, &d, n * nr_dentry_in_block))
./fs/hmfs/dir.c:const struct file_operations hmfs_dir_operations = {
./fs/hmfs/dir.c:	.iterate = hmfs_readdir,
./fs/hmfs/dir.c:	.fsync = hmfs_sync_file,
./fs/hmfs/dir.c:	.unlocked_ioctl = hmfs_ioctl,
./fs/hmfs/readme.md:<pre>mount -t hmfs -o physaddr=0x40000000,init=2G,gid=yourgid,uid=youruid none ~/mnt-hmfs</pre>
./fs/hmfs/debug.c:#include "hmfs_fs.h"
./fs/hmfs/debug.c:static LIST_HEAD(hmfs_stat_list);
./fs/hmfs/debug.c:static int hmfs_dispatch_cmd(struct hmfs_sb_info *, const char *cmd);
./fs/hmfs/debug.c:void update_nat_stat(struct hmfs_sb_info *sbi, int flush_count)
./fs/hmfs/debug.c:	struct hmfs_stat_info *stat_i = STAT_I(sbi);
./fs/hmfs/debug.c:	lock_hmfs_stat(stat_i);
./fs/hmfs/debug.c:	unlock_hmfs_stat(stat_i);
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = s->private;
./fs/hmfs/debug.c:	struct hmfs_sb_info *sbi = si->sbi;
./fs/hmfs/debug.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/debug.c:	struct hmfs_sm_info *sm_i = SM_I(sbi);
./fs/hmfs/debug.c:	unsigned long max_file_size = hmfs_max_file_size();
./fs/hmfs/debug.c:static char get_segment_state(struct hmfs_sb_info *sbi, seg_t i)
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = s->private;
./fs/hmfs/debug.c:	struct hmfs_sb_info *sbi = si->sbi;
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = inode->i_private;
./fs/hmfs/debug.c:		hmfs_dispatch_cmd(si->sbi, si->cmd);
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = inode->i_private;
./fs/hmfs/debug.c:static int hmfs_build_info(struct hmfs_sb_info *sbi, size_t c)
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = STAT_I(sbi);
./fs/hmfs/debug.c:static void hmfs_destroy_info(struct hmfs_sb_info *sbi)
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = STAT_I(sbi);
./fs/hmfs/debug.c:int hmfs_build_stats(struct hmfs_sb_info *sbi)
./fs/hmfs/debug.c:	struct hmfs_stat_info *si;
./fs/hmfs/debug.c:	sbi->stat_info = kzalloc(sizeof(struct hmfs_stat_info), GFP_KERNEL);
./fs/hmfs/debug.c:	memset(sbi->stat_info, 0, sizeof(struct hmfs_stat_info));
./fs/hmfs/debug.c:	ret = hmfs_build_info(sbi, 1 << 20);
./fs/hmfs/debug.c:void hmfs_destroy_stats(struct hmfs_sb_info *sbi)
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = sbi->stat_info;
./fs/hmfs/debug.c:	hmfs_destroy_info(sbi);
./fs/hmfs/debug.c:void hmfs_create_root_stat(void)
./fs/hmfs/debug.c:	debugfs_root = debugfs_create_dir("hmfs", NULL);
./fs/hmfs/debug.c:void hmfs_destroy_root_stat(void)
./fs/hmfs/debug.c:int hmfs_print(struct hmfs_stat_info *si, int mode, const char *fmt, ...)
./fs/hmfs/debug.c:int __hmfs_print(struct hmfs_stat_info *si, void * source, int len)
./fs/hmfs/debug.c:static int print_cp_one(struct hmfs_sb_info *sbi, struct hmfs_checkpoint *cp,
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = STAT_I(sbi);
./fs/hmfs/debug.c:	len += hmfs_print(si, 1, "version: %u\n", le32_to_cpu(cp->checkpoint_ver));
./fs/hmfs/debug.c:		len += hmfs_print(si, 1, "------detail info------\n");
./fs/hmfs/debug.c:		len += hmfs_print(si, 1, "checkpoint_ver: %u\n", 
./fs/hmfs/debug.c:		len += hmfs_print(si, 1, "alloc_block_count: %u\n",
./fs/hmfs/debug.c:		len += hmfs_print(si, 1, "valid_block_count: %u\n",
./fs/hmfs/debug.c:			len += hmfs_print(si, 1, "current segment (%d)[%lu, %lu]\n", i,
./fs/hmfs/debug.c:		len += hmfs_print(si, 1, "prev_cp_addr: %x\n",
./fs/hmfs/debug.c:		len += hmfs_print(si, 1, "next_cp_addr: %x\n",
./fs/hmfs/debug.c:		len += hmfs_print(si, 1, "valid_inode_count: %u\n",
./fs/hmfs/debug.c:		len += hmfs_print(si, 1, "valid_node_count: %u\n",
./fs/hmfs/debug.c:		len += hmfs_print(si, 1, "nat_addr: %x\n", 
./fs/hmfs/debug.c:				len += hmfs_print(si, 1, "orphan_addr[%d]: %lu\n", i,
./fs/hmfs/debug.c:		len += hmfs_print(si, 1, "next_scan_nid: %u\n",
./fs/hmfs/debug.c:		len += hmfs_print(si, 1, "elapsed_time: %u\n",
./fs/hmfs/debug.c:		len += hmfs_print(si, 1, "\n\n");
./fs/hmfs/debug.c:static int print_cp_nth(struct hmfs_sb_info *sbi, int n, int detail)
./fs/hmfs/debug.c:	struct hmfs_cm_info *cmi = CM_I(sbi);
./fs/hmfs/debug.c:	struct hmfs_checkpoint *hmfs_cp = NULL;
./fs/hmfs/debug.c:	hmfs_cp = cpi->cp;
./fs/hmfs/debug.c:		next_addr = le64_to_cpu(hmfs_cp->next_cp_addr);
./fs/hmfs/debug.c:		hmfs_cp = ADDR(sbi, next_addr);
./fs/hmfs/debug.c:	return print_cp_one(sbi, hmfs_cp, detail);
./fs/hmfs/debug.c:static int print_cp_all(struct hmfs_sb_info *sbi, int detail)
./fs/hmfs/debug.c:	struct hmfs_cm_info *cmi = CM_I(sbi);
./fs/hmfs/debug.c:	struct hmfs_checkpoint *hmfs_cp = NULL;
./fs/hmfs/debug.c:	hmfs_cp = cpi->cp;
./fs/hmfs/debug.c:		next_addr = le64_to_cpu(hmfs_cp->next_cp_addr);
./fs/hmfs/debug.c:		hmfs_cp = ADDR(sbi, next_addr);
./fs/hmfs/debug.c:		len += print_cp_one(sbi, hmfs_cp, detail);
./fs/hmfs/debug.c:	} while (hmfs_cp != cpi->cp);
./fs/hmfs/debug.c:static int hmfs_print_cp(struct hmfs_sb_info *sbi, int args, char argv[][MAX_ARG_LEN + 1])
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = STAT_I(sbi);
./fs/hmfs/debug.c:		hmfs_print(si, 1, "======Current checkpoint info======\n");
./fs/hmfs/debug.c:		hmfs_print(si, 1, "======Total checkpoints info======\n");
./fs/hmfs/debug.c:		if (hmfs_readonly(sbi->sb))
./fs/hmfs/debug.c:			len = hmfs_print(si, 0, "Readonly\n");
./fs/hmfs/debug.c:			len = hmfs_print(si, 0, "Delete checkpoint %3d: %d\n", v, detail);
./fs/hmfs/debug.c:		hmfs_print(si, 1, "======%luth checkpoint info======\n", n);
./fs/hmfs/debug.c:static size_t print_ssa_one(struct hmfs_sb_info *sbi, block_t blk_addr)
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = STAT_I(sbi);
./fs/hmfs/debug.c:	struct hmfs_summary *sum_entry;
./fs/hmfs/debug.c:	len += hmfs_print(si, 1, "-- [%d %d] --\n", GET_SEGNO(sbi, blk_addr), GET_SEG_OFS(sbi, blk_addr));
./fs/hmfs/debug.c:	len += hmfs_print(si, 1, "  nid: %u\n", le32_to_cpu(sum_entry->nid));
./fs/hmfs/debug.c:	len += hmfs_print(si, 1, "  start_version: %u\n",
./fs/hmfs/debug.c:	len += hmfs_print(si, 1, "  ofs_in_node: %u\n", get_summary_offset(sum_entry));
./fs/hmfs/debug.c:	len += hmfs_print(si, 1, "  type: %u\n", get_summary_type(sum_entry));
./fs/hmfs/debug.c:	len += hmfs_print(si, 1, "  v bit: %u\n", !!get_summary_valid_bit(sum_entry));
./fs/hmfs/debug.c:	len += hmfs_print(si, 1, "\n");
./fs/hmfs/debug.c:static int print_ssa_range(struct hmfs_sb_info *sbi, block_t idx_from, block_t idx_to)
./fs/hmfs/debug.c:	//struct hmfs_summary_block* sum_blk = get_summary_block(sbi, blkidx);
./fs/hmfs/debug.c:static size_t print_ssa_per_seg(struct hmfs_sb_info *sbi, block_t segno)
./fs/hmfs/debug.c:static int hmfs_print_ssa(struct hmfs_sb_info *sbi, int args, char argv[][MAX_ARG_LEN + 1])
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = STAT_I(sbi);
./fs/hmfs/debug.c:	hmfs_print(si, 0, "======= SSA INFO =======\n");
./fs/hmfs/debug.c:		hmfs_print(si, 0, " **error** invalid index: %llu\n", idx_from);
./fs/hmfs/debug.c:static inline int get_vblocks_from_sit(struct hmfs_sb_info *sbi, seg_t segno)
./fs/hmfs/debug.c:static inline int print_error_segment(struct hmfs_sb_info *sbi, 
./fs/hmfs/debug.c:	return hmfs_print(STAT_I(sbi), 1, "segment #%d *ERROR*, cnt in SIT: %d"
./fs/hmfs/debug.c:static int hmfs_print_sit(struct hmfs_sb_info *sbi, int args, char argv[][MAX_ARG_LEN + 1])
./fs/hmfs/debug.c:	struct hmfs_summary *ssa_entry;
./fs/hmfs/debug.c:			len += hmfs_print(STAT_I(sbi), 1, "segno = %llu, valid blocks = %llu\n", segno, seg_entry->valid_blocks);
./fs/hmfs/debug.c:	len += hmfs_print(STAT_I(sbi), 1, "total dirty segments = %lu, total valid blocks = %lu, disk usage = %f %% \n",\
./fs/hmfs/debug.c:		len = hmfs_print(STAT_I(sbi), 1, "no error found in SIT check!\n");
./fs/hmfs/debug.c:static int hmfs_print_nat(struct hmfs_sb_info *sbi, int args, char argv[][MAX_ARG_LEN + 1])
./fs/hmfs/debug.c:static int hmfs_print_data(struct hmfs_sb_info *sbi, int args, char argv[][MAX_ARG_LEN + 1])
./fs/hmfs/debug.c:	struct hmfs_summary *summary = get_summary_by_addr(sbi, addr);
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = STAT_I(sbi);
./fs/hmfs/debug.c:	len += hmfs_print(si, 0, "Data[%u %u](%d)\n", GET_SEGNO(sbi, addr), GET_SEG_OFS(sbi, addr),
./fs/hmfs/debug.c:	len += __hmfs_print(si, ADDR(sbi, addr), HMFS_MIN_PAGE_SIZE);
./fs/hmfs/debug.c:static int hmfs_check_ssa(struct hmfs_sb_info *sbi, block_t cp_addr, block_t blk_addr,
./fs/hmfs/debug.c:	struct hmfs_checkpoint* cp;
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = STAT_I(sbi);
./fs/hmfs/debug.c:	struct hmfs_summary* summary;
./fs/hmfs/debug.c:	cp = (struct hmfs_checkpoint *)ADDR(sbi, cp_addr);
./fs/hmfs/debug.c:		hmfs_print(si, 1, "**error** summary type error: ");
./fs/hmfs/debug.c:		hmfs_print(si, 1, "type of nat node at %#x should be %d, but get %d \n",
./fs/hmfs/debug.c:			hmfs_print(si, 1, "**error** summary offset error: ");
./fs/hmfs/debug.c:			hmfs_print(si, 1, "offset nat node at %#x should be %d, but get %d \n",
./fs/hmfs/debug.c:			hmfs_print(si, 1, "**error** summary height error: ");
./fs/hmfs/debug.c:			hmfs_print(si, 1, "offset nat node at %#x should be %d, but get %llu \n",
./fs/hmfs/debug.c:			hmfs_print(si, 1, "**error** summary block order error: ");
./fs/hmfs/debug.c:			hmfs_print(si, 1, "offset nat node at %#x should be %d, but get %llu \n",
./fs/hmfs/debug.c:static int traverse_nat(struct hmfs_sb_info *sbi, block_t cp_addr,
./fs/hmfs/debug.c:	struct hmfs_nat_node *root;
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = STAT_I(sbi);
./fs/hmfs/debug.c:	err = hmfs_check_ssa(sbi, cp_addr, root_addr, h, offset, nid);
./fs/hmfs/debug.c:		hmfs_print(si, 1, "\n----- ERROR BLK INFO -----\n");
./fs/hmfs/debug.c:		hmfs_print(si, 1, "--------------------------\n");
./fs/hmfs/debug.c:		hmfs_print(si, 1, ">>>>>>>>>>> %p -> %p, height is %d\n", root_addr,
./fs/hmfs/debug.c:static int hmfs_consis(struct hmfs_sb_info *sbi)
./fs/hmfs/debug.c:	struct hmfs_super_block *sb = HMFS_RAW_SUPER(sbi);
./fs/hmfs/debug.c:	struct hmfs_cm_info *cmi = sbi->cm_info;
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = STAT_I(sbi);
./fs/hmfs/debug.c:	hmfs_print(si, 1, "cmi->valid_inode: %d\n", cmi->valid_inode_count);
./fs/hmfs/debug.c:	hmfs_print(si, 1, "======= check summary ======\n");
./fs/hmfs/debug.c:		struct hmfs_checkpoint *cp;
./fs/hmfs/debug.c:		hmfs_print(si, 1, "checkpoint address: %#x\n", cp_addr);
./fs/hmfs/debug.c:		hmfs_print(si, 1, "valid inode count: %d\n",
./fs/hmfs/debug.c:		hmfs_print(si, 1, "valid node count: %d\n",
./fs/hmfs/debug.c:	hmfs_print(si, 1, "=== check summary done ===\n");
./fs/hmfs/debug.c:static int hmfs_parse_cmd(const char *cmd, size_t len, char argv[][MAX_ARG_LEN + 1])
./fs/hmfs/debug.c:static int hmfs_print_inode(struct hmfs_sb_info *sbi, int args,	char argv[][MAX_ARG_LEN + 1])
./fs/hmfs/debug.c:	struct hmfs_stat_info *si= STAT_I(sbi);
./fs/hmfs/debug.c:	struct hmfs_node *hn;
./fs/hmfs/debug.c:	struct hmfs_summary *sum;
./fs/hmfs/debug.c:		len += hmfs_print(si, 0, "Inode %d infomation\n", ino);
./fs/hmfs/debug.c:			len += hmfs_print(si, 1, "Not exist\n");
./fs/hmfs/debug.c:			len += hmfs_print(si, 1, "Node type: Inode\n");
./fs/hmfs/debug.c:			len += hmfs_print(si, 1, "mode:%s\n", judge_file_type(hn->i.i_mode));
./fs/hmfs/debug.c:			len += hmfs_print(si, 1, "size:%lu\n", le64_to_cpu(hn->i.i_size));
./fs/hmfs/debug.c:			len += hmfs_print(si, 1, "name:%s\n", hn->i.i_name);
./fs/hmfs/debug.c:			len += hmfs_print(si, 1, "block type:%d %d\n", hn->i.i_blk_type, 
./fs/hmfs/debug.c:			len += hmfs_print(si, 1, "height: %d\n", hn->i.i_height);
./fs/hmfs/debug.c:			len += hmfs_print(si, 1, "nid: %d\n", hn->i.i_nid);
./fs/hmfs/debug.c:				len += hmfs_print(si, 1, "i_addr[%d]:%lu(%d %d)\n", i, addr,
./fs/hmfs/debug.c:			len += hmfs_print(si, 1, "Node type: Direct node\n");
./fs/hmfs/debug.c:				len += hmfs_print(si, 1, "addr[%d]:%lu(%d %d)\n", i, addr,
./fs/hmfs/debug.c:			len += hmfs_print(si, 1, "Node type: Indirect node\n");
./fs/hmfs/debug.c:		len += hmfs_print(si, 0, "Invalid arguments\n");
./fs/hmfs/debug.c:static int hmfs_dispatch_cmd(struct hmfs_sb_info *sbi, const char *cmd)
./fs/hmfs/debug.c:	struct hmfs_stat_info *si = STAT_I(sbi);
./fs/hmfs/debug.c:	args = hmfs_parse_cmd(cmd, len, argv);
./fs/hmfs/debug.c:		hmfs_print(si, 0, USAGE);
./fs/hmfs/debug.c:	hmfs_print(si, 0, "");	//clear the buffer
./fs/hmfs/debug.c:			hmfs_print(si, 0, USAGE_CP);
./fs/hmfs/debug.c:		res = hmfs_print_cp(sbi, args, argv);
./fs/hmfs/debug.c:			hmfs_print(si, 0, USAGE_SSA);
./fs/hmfs/debug.c:		res = hmfs_print_ssa(sbi, args, argv);
./fs/hmfs/debug.c:			hmfs_print(si, 0, USAGE_SIT);
./fs/hmfs/debug.c:			res = hmfs_print_sit(sbi, args, argv);
./fs/hmfs/debug.c:			hmfs_print(si, 0, USAGE_NAT);
./fs/hmfs/debug.c:		res = hmfs_print_nat(sbi, args, argv);
./fs/hmfs/debug.c:			hmfs_print(si, 0, USAGE_DATA);
./fs/hmfs/debug.c:		res = hmfs_print_data(sbi, args, argv);
./fs/hmfs/debug.c:			hmfs_print(si, 0, USAGE_INODE);
./fs/hmfs/debug.c:		res = hmfs_print_inode(sbi, args, argv);
./fs/hmfs/debug.c:		res = hmfs_consis(sbi);
./fs/hmfs/debug.c:		hmfs_print(si, 0, USAGE);
./fs/hmfs/checkpoint.c:#include "hmfs.h"
./fs/hmfs/checkpoint.c:#include "hmfs_fs.h"
./fs/hmfs/checkpoint.c:static void modify_checkpoint_version(struct hmfs_sb_info *sbi, void *block,
./fs/hmfs/checkpoint.c:	struct hmfs_summary *summary;
./fs/hmfs/checkpoint.c:		struct hmfs_nat_entry *entry;
./fs/hmfs/checkpoint.c:		struct hmfs_inode *inode_block;
./fs/hmfs/checkpoint.c:		struct hmfs_checkpoint *cur_cp;
./fs/hmfs/checkpoint.c:		hmfs_bug_on(sbi, 1);
./fs/hmfs/checkpoint.c:void recycle_version_number(struct hmfs_sb_info *sbi)
./fs/hmfs/checkpoint.c:	struct hmfs_checkpoint *cur_cp, *last_cp;
./fs/hmfs/checkpoint.c:static void init_orphan_manager(struct hmfs_cm_info *cm_i)
./fs/hmfs/checkpoint.c:void add_orphan_inode(struct hmfs_sb_info *sbi, nid_t ino)
./fs/hmfs/checkpoint.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/checkpoint.c:void remove_orphan_inode(struct hmfs_sb_info *sbi, nid_t ino)
./fs/hmfs/checkpoint.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/checkpoint.c:int check_orphan_space(struct hmfs_sb_info *sbi)
./fs/hmfs/checkpoint.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/checkpoint.c:static void sync_checkpoint_info(struct hmfs_sb_info *sbi,
./fs/hmfs/checkpoint.c:				struct hmfs_checkpoint *hmfs_cp,
./fs/hmfs/checkpoint.c:	cp->version = le32_to_cpu(hmfs_cp->checkpoint_ver);
./fs/hmfs/checkpoint.c:	cp->nat_root = ADDR(sbi, le64_to_cpu(hmfs_cp->nat_addr));
./fs/hmfs/checkpoint.c:	cp->cp = hmfs_cp;
./fs/hmfs/checkpoint.c:static void move_to_next_cp(struct hmfs_sb_info *sbi,
./fs/hmfs/checkpoint.c:				struct hmfs_checkpoint *prev_cp)
./fs/hmfs/checkpoint.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/checkpoint.c:struct checkpoint_info *get_next_checkpoint_info(struct hmfs_sb_info *sbi,
./fs/hmfs/checkpoint.c:	struct hmfs_checkpoint *this_cp, *next_cp;
./fs/hmfs/checkpoint.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/checkpoint.c:struct checkpoint_info *get_checkpoint_info(struct hmfs_sb_info *sbi,
./fs/hmfs/checkpoint.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/checkpoint.c:	struct hmfs_checkpoint *hmfs_cp;
./fs/hmfs/checkpoint.c:		hmfs_bug_on(sbi, version > cp_i->version);
./fs/hmfs/checkpoint.c:			hmfs_cp = ADDR(sbi, next_addr);
./fs/hmfs/checkpoint.c:			entry = radix_tree_lookup(&cm_i->cp_tree_root, le32_to_cpu(hmfs_cp->checkpoint_ver));
./fs/hmfs/checkpoint.c:				sync_checkpoint_info(sbi, hmfs_cp, entry);
./fs/hmfs/checkpoint.c:static struct hmfs_checkpoint *get_mnt_checkpoint(struct hmfs_sb_info *sbi,
./fs/hmfs/checkpoint.c:				struct hmfs_checkpoint *cp,	ver_t version)
./fs/hmfs/checkpoint.c:	struct hmfs_checkpoint *entry = cp;
./fs/hmfs/checkpoint.c:void check_checkpoint_state(struct hmfs_sb_info *sbi)
./fs/hmfs/checkpoint.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/checkpoint.c:	struct hmfs_checkpoint *hmfs_cp = cm_i->last_cp_i->cp;
./fs/hmfs/checkpoint.c:	state = hmfs_cp->state;
./fs/hmfs/checkpoint.c:		recovery_gc_crash(sbi, hmfs_cp);
./fs/hmfs/checkpoint.c:		redo_checkpoint(sbi, hmfs_cp);
./fs/hmfs/checkpoint.c:	set_fs_state(hmfs_cp, HMFS_NONE);
./fs/hmfs/checkpoint.c:int init_checkpoint_manager(struct hmfs_sb_info *sbi)
./fs/hmfs/checkpoint.c:	struct hmfs_cm_info *cm_i;
./fs/hmfs/checkpoint.c:	struct hmfs_super_block *super = ADDR(sbi, 0);
./fs/hmfs/checkpoint.c:	struct hmfs_checkpoint *hmfs_cp;
./fs/hmfs/checkpoint.c:	hmfs_cp = ADDR(sbi, cp_addr);
./fs/hmfs/checkpoint.c:	if (sbi->mnt_cp_version && sbi->mnt_cp_version != le32_to_cpu(hmfs_cp->checkpoint_ver)) {
./fs/hmfs/checkpoint.c:		hmfs_cp = get_mnt_checkpoint(sbi, hmfs_cp, sbi->mnt_cp_version);
./fs/hmfs/checkpoint.c:		if (!hmfs_cp)
./fs/hmfs/checkpoint.c:	cm_i = kzalloc(sizeof(struct hmfs_cm_info), GFP_KERNEL);
./fs/hmfs/checkpoint.c:	cm_i->valid_inode_count = le32_to_cpu(hmfs_cp->valid_inode_count);
./fs/hmfs/checkpoint.c:	cm_i->valid_node_count = le32_to_cpu(hmfs_cp->valid_node_count);
./fs/hmfs/checkpoint.c:	cm_i->valid_block_count = le32_to_cpu(hmfs_cp->valid_block_count);
./fs/hmfs/checkpoint.c:	cm_i->alloc_block_count = le32_to_cpu(hmfs_cp->alloc_block_count);
./fs/hmfs/checkpoint.c:	sync_checkpoint_info(sbi, hmfs_cp, cp_i);
./fs/hmfs/checkpoint.c:	cm_i->new_version = next_cp_ver(le32_to_cpu(hmfs_cp->checkpoint_ver));
./fs/hmfs/checkpoint.c:static void destroy_checkpoint_info(struct hmfs_cm_info *cm_i)
./fs/hmfs/checkpoint.c:int destroy_checkpoint_manager(struct hmfs_sb_info *sbi)
./fs/hmfs/checkpoint.c:	struct hmfs_cm_info *cm_i = sbi->cm_info;
./fs/hmfs/checkpoint.c:	orphan_entry_slab = hmfs_kmem_cache_create("hmfs_orphan_entry",
./fs/hmfs/checkpoint.c:	cp_info_entry_slab = hmfs_kmem_cache_create("hmfs_checkpoint_info_entry",
./fs/hmfs/checkpoint.c:static int sync_dirty_inodes(struct hmfs_sb_info *sbi)
./fs/hmfs/checkpoint.c:	struct hmfs_inode_info *fi;
./fs/hmfs/checkpoint.c:		fi = list_entry(this, struct hmfs_inode_info, list);
./fs/hmfs/checkpoint.c:		ret = __hmfs_write_inode(&fi->vfs_inode, true);
./fs/hmfs/checkpoint.c:static int block_operations(struct hmfs_sb_info *sbi)
./fs/hmfs/checkpoint.c:static void unblock_operations(struct hmfs_sb_info *sbi)
./fs/hmfs/checkpoint.c:static int flush_orphan_inodes(struct hmfs_sb_info *sbi, block_t *orphan_addrs)
./fs/hmfs/checkpoint.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/checkpoint.c:	struct hmfs_summary *summary;
./fs/hmfs/checkpoint.c:	hmfs_bug_on(sbi, i > NUM_ORPHAN_BLOCKS);
./fs/hmfs/checkpoint.c:static void flush_orphan_inodes_finish(struct hmfs_sb_info *sbi, 
./fs/hmfs/checkpoint.c:	struct hmfs_checkpoint *hmfs_cp = ADDR(sbi, cp_addr);
./fs/hmfs/checkpoint.c:			hmfs_cp->orphan_addrs[i] = cpu_to_le64(*orphan_addrs);
./fs/hmfs/checkpoint.c:static void recover_orphan_inode(struct hmfs_sb_info *sbi, nid_t ino)
./fs/hmfs/checkpoint.c:	struct inode *inode = hmfs_iget(sbi->sb, ino);
./fs/hmfs/checkpoint.c:	hmfs_bug_on(sbi, IS_ERR(inode));
./fs/hmfs/checkpoint.c:int recover_orphan_inodes(struct hmfs_sb_info *sbi)
./fs/hmfs/checkpoint.c:	struct hmfs_checkpoint *hmfs_cp = CM_I(sbi)->last_cp_i->cp;
./fs/hmfs/checkpoint.c:		orphan_addr = le64_to_cpu(hmfs_cp->orphan_addrs[i]);
./fs/hmfs/checkpoint.c:void display_warp(struct hmfs_sb_info *sbi) {
./fs/hmfs/checkpoint.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/checkpoint.c:	struct hmfs_summary *summary;
./fs/hmfs/checkpoint.c:	struct hmfs_inode_info *fi = NULL;
./fs/hmfs/checkpoint.c:	//struct hmfs_proc_info *proc = NULL;
./fs/hmfs/checkpoint.c:				hmfs_dbg("-------- NID: %d --------\n",i);
./fs/hmfs/checkpoint.c:				hmfs_dbg("[WARP] nid:%d b:%u [%s] \tino:%d \tE[%s] Sum[%s][%s].\n",ne->ni.nid,ne->ni.begin_version,type_name,(int)ne->ni.ino,cur_warp_type_name,next_warp_type_name,warp_type_name);
./fs/hmfs/checkpoint.c:				hmfs_dbg("[WARP] nr=%lu sr=%llu nw=%lu sw=%llu\n", ne->ni.nread, ne->ni.sread, ne->ni.nwrite, ne->ni.swrite);
./fs/hmfs/checkpoint.c:				hmfs_dbg("[WARP] normal=%llu read=%llu write=%llu\n",mnormal,mread,mwrite);
./fs/hmfs/checkpoint.c:				inode = hmfs_iget(sbi->sb, ne->ni.ino);
./fs/hmfs/checkpoint.c:					hmfs_dbg("[PROC] pid:%llu \t ino:%lu \t nid:%lu\n", fi->i_proc_info[j].proc_id, (unsigned long)fi->i_proc_info[j].next_ino, (unsigned long)fi->i_proc_info[j].next_nid);
./fs/hmfs/checkpoint.c:				// if (this) hmfs_dbg("[PROC] next ino:%d \t next nid:%d\n", this->ino, this->nid);
./fs/hmfs/checkpoint.c:				hmfs_dbg("-------- NID: %d --------\n",i);
./fs/hmfs/checkpoint.c:static int do_checkpoint(struct hmfs_sb_info *sbi)
./fs/hmfs/checkpoint.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/checkpoint.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/checkpoint.c:	struct hmfs_super_block *raw_super = HMFS_RAW_SUPER(sbi);
./fs/hmfs/checkpoint.c:	struct hmfs_summary *summary;
./fs/hmfs/checkpoint.c:	struct hmfs_nat_node *nat_root = NULL;
./fs/hmfs/checkpoint.c:	struct hmfs_checkpoint *prev_cp, *next_cp;
./fs/hmfs/checkpoint.c:	struct hmfs_checkpoint *cur_cp;
./fs/hmfs/checkpoint.c:	hmfs_memcpy_atomic(&prev_cp->next_cp_addr, &cur_cp_addr, 8);
./fs/hmfs/checkpoint.c:	hmfs_memcpy_atomic(&next_cp->prev_cp_addr,&cur_cp_addr, 8);
./fs/hmfs/checkpoint.c:	hmfs_memcpy_atomic(&raw_super->cp_page_addr, &cur_cp_addr, 8);
./fs/hmfs/checkpoint.c:	sb_checksum = hmfs_make_checksum(raw_super);
./fs/hmfs/checkpoint.c:	hmfs_memcpy(raw_super, HMFS_RAW_SUPER(sbi), sizeof(struct hmfs_super_block));
./fs/hmfs/checkpoint.c:	hmfs_dbg("[CP] : Snapshot version: %u\n",store_version);
./fs/hmfs/checkpoint.c:int write_checkpoint(struct hmfs_sb_info *sbi, bool unlock)
./fs/hmfs/checkpoint.c:	hmfs_dbg("[CP] : berfore do_checkpoint\n");
./fs/hmfs/checkpoint.c:	hmfs_dbg("[CP] : write checkpoint\n");
./fs/hmfs/checkpoint.c:	if(!sbi->turn_off_warp) hmfs_warp_update(sbi);
./fs/hmfs/checkpoint.c:	hmfs_dbg("[CP] : after do_checkpoint\n");
./fs/hmfs/checkpoint.c:int redo_checkpoint(struct hmfs_sb_info *sbi, struct hmfs_checkpoint *prev_cp)
./fs/hmfs/checkpoint.c:	struct hmfs_super_block *raw_super = HMFS_RAW_SUPER(sbi);
./fs/hmfs/checkpoint.c:	struct hmfs_summary *summary;
./fs/hmfs/checkpoint.c:	struct hmfs_checkpoint *next_cp;
./fs/hmfs/checkpoint.c:	struct hmfs_checkpoint *store_cp;
./fs/hmfs/checkpoint.c:	hmfs_bug_on(sbi, L_ADDR(sbi, prev_cp)!=
./fs/hmfs/checkpoint.c:	hmfs_memcpy_atomic(&prev_cp->next_cp_addr, &store_cp_addr, 8);
./fs/hmfs/checkpoint.c:	hmfs_memcpy_atomic(&next_cp->prev_cp_addr, &store_cp_addr, 8);
./fs/hmfs/checkpoint.c:	hmfs_memcpy_atomic(&raw_super->cp_page_addr, &store_cp_addr, 8);
./fs/hmfs/checkpoint.c:	sb_checksum = hmfs_make_checksum(raw_super);
./fs/hmfs/checkpoint.c:	hmfs_memcpy(raw_super, ADDR(sbi, 0), sizeof(struct hmfs_super_block));
./fs/hmfs/checkpoint.c:static void invalidate_block(struct hmfs_sb_info *sbi, block_t addr,
./fs/hmfs/checkpoint.c:				struct hmfs_summary *summary)
./fs/hmfs/checkpoint.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/checkpoint.c:	//hmfs_dbg("[HMFS] : invalidate block, segno = %llu, count = %d\n", segno, nr_free);
./fs/hmfs/checkpoint.c:static int __delete_checkpoint(struct hmfs_sb_info *sbi, void *cur_node,
./fs/hmfs/checkpoint.c:	struct hmfs_summary *cur_sum, *next_sum;
./fs/hmfs/checkpoint.c:		hmfs_bug_on(sbi, cur_node_ver > next_node_ver);
./fs/hmfs/checkpoint.c:		struct hmfs_nat_entry *cur_entry, *next_entry;
./fs/hmfs/checkpoint.c:			hmfs_bug_on(sbi, !next_entry);
./fs/hmfs/checkpoint.c:		struct hmfs_inode *cur_inode, *next_inode;
./fs/hmfs/checkpoint.c:		cur_inode = (struct hmfs_inode *)cur_node;
./fs/hmfs/checkpoint.c:		next_inode = (struct hmfs_inode *)next_node;
./fs/hmfs/checkpoint.c:		hmfs_bug_on(sbi, 1);
./fs/hmfs/checkpoint.c:		hmfs_bug_on(sbi, 1);
./fs/hmfs/checkpoint.c:static int do_delete_checkpoint(struct hmfs_sb_info *sbi, block_t cur_addr)
./fs/hmfs/checkpoint.c:	struct hmfs_checkpoint *next_cp, *prev_cp, *last_cp, *cur_cp;
./fs/hmfs/checkpoint.c:	struct hmfs_nat_node *cur_root = NULL, *next_root = NULL;
./fs/hmfs/checkpoint.c:	struct hmfs_summary *summary;
./fs/hmfs/checkpoint.c:	struct hmfs_super_block *raw_super;
./fs/hmfs/checkpoint.c:		hmfs_bug_on(sbi, cur_cp != next_cp);
./fs/hmfs/checkpoint.c:		hmfs_dbg("[CP] : It's not allowed to delete the newest checkpoint\n");
./fs/hmfs/checkpoint.c:		raw_super->checksum = cpu_to_le16(hmfs_make_checksum(raw_super));
./fs/hmfs/checkpoint.c:		hmfs_memcpy(raw_super, HMFS_RAW_SUPER(sbi), sizeof(struct hmfs_super_block));
./fs/hmfs/checkpoint.c:int delete_checkpoint(struct hmfs_sb_info *sbi, ver_t version)
./fs/hmfs/checkpoint.c:int redo_delete_checkpoint(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs_fs.h:typedef __le32 hmfs_hash_t;
./fs/hmfs/hmfs_fs.h:#define hmfs_make_checksum(obj)	crc16(~0, (void *)obj, (char *)(&obj->checksum) - \
./fs/hmfs/hmfs_fs.h:#define DENTRY_BLOCK(ptr)	((struct hmfs_dentry_block *)ptr)
./fs/hmfs/hmfs_fs.h:#define NUM_NAT_JOURNALS_IN_CP	(3892 / sizeof(struct hmfs_nat_journal))
./fs/hmfs/hmfs_fs.h:#define SIT_ENTRY_SIZE (sizeof(struct hmfs_sit_entry))
./fs/hmfs/hmfs_fs.h:struct hmfs_super_block {
./fs/hmfs/hmfs_fs.h:/* hmfs inode */
./fs/hmfs/hmfs_fs.h:struct hmfs_inode {
./fs/hmfs/hmfs_fs.h:        struct hmfs_proc{
./fs/hmfs/hmfs_fs.h:/* hmfs node */
./fs/hmfs/hmfs_fs.h:struct hmfs_node {
./fs/hmfs/hmfs_fs.h:		struct hmfs_inode i;
./fs/hmfs/hmfs_fs.h:struct hmfs_nat_node {
./fs/hmfs/hmfs_fs.h:struct hmfs_nat_entry {
./fs/hmfs/hmfs_fs.h:#define NAT_ENTRY_PER_BLOCK		(HMFS_MIN_PAGE_SIZE / sizeof(struct hmfs_nat_entry))
./fs/hmfs/hmfs_fs.h:struct hmfs_nat_block {
./fs/hmfs/hmfs_fs.h:	struct hmfs_nat_entry entries[NAT_ENTRY_PER_BLOCK];
./fs/hmfs/hmfs_fs.h:struct hmfs_nat_journal {
./fs/hmfs/hmfs_fs.h:	struct hmfs_nat_entry entry;
./fs/hmfs/hmfs_fs.h:struct hmfs_sit_entry {
./fs/hmfs/hmfs_fs.h:struct hmfs_sit_log_entry {
./fs/hmfs/hmfs_fs.h:struct hmfs_sit_log_segment {
./fs/hmfs/hmfs_fs.h:	struct hmfs_sit_log_entry entries[1];
./fs/hmfs/hmfs_fs.h:struct hmfs_dir_entry {
./fs/hmfs/hmfs_fs.h:struct hmfs_dentry_block {
./fs/hmfs/hmfs_fs.h:	struct hmfs_dir_entry dentry[NR_DENTRY_IN_BLOCK];
./fs/hmfs/hmfs_fs.h:				SIZE_OF_RESERVED) / (sizeof(struct hmfs_dir_entry) + \
./fs/hmfs/hmfs_fs.h:struct hmfs_checkpoint {
./fs/hmfs/hmfs_fs.h:	struct hmfs_nat_journal nat_journals[NUM_NAT_JOURNALS_IN_CP];
./fs/hmfs/hmfs_fs.h:				(&(((struct hmfs_inode *)NULL)->i_xattr_addr)))
./fs/hmfs/hmfs_fs.h:				(&(((struct hmfs_inode *)NULL)->i_acl_addr)))
./fs/hmfs/hmfs_fs.h:#define HMFS_NAT_NODE(ptr)		((struct hmfs_nat_node *)(ptr))
./fs/hmfs/hmfs_fs.h:#define HMFS_NAT_BLOCK(ptr)		((struct hmfs_nat_block *)(ptr))
./fs/hmfs/hmfs_fs.h:#define HMFS_INODE(ptr)			((struct hmfs_inode *)(ptr))
./fs/hmfs/hmfs_fs.h:#define HMFS_NODE(ptr)			((struct hmfs_node *)(ptr))
./fs/hmfs/hmfs_fs.h:#define HMFS_CHECKPOINT(ptr)	((struct hmfs_checkpoint *)(ptr))
./fs/hmfs/hmfs_fs.h:#define HMFS_SUMMARY(ptr)		((struct hmfs_summary *)(ptr))
./fs/hmfs/hmfs_fs.h:#define HMFS_SUPER_BLOCK(ptr)	((struct hmfs_super_block *)(ptr))
./fs/hmfs/hmfs_fs.h:static inline void hmfs_memcpy(void *dest, void *src, unsigned long length)
./fs/hmfs/hmfs_fs.h:struct hmfs_summary {
./fs/hmfs/hmfs_fs.h:static inline void hmfs_memcpy_atomic(void *dest, const void *src, u8 size)
./fs/hmfs/hmfs_fs.h:static inline void set_fs_state_arg(struct hmfs_checkpoint *hmfs_cp, u64 value)
./fs/hmfs/hmfs_fs.h:	hmfs_memcpy_atomic(&hmfs_cp->state_arg, &value, 8);
./fs/hmfs/hmfs_fs.h:static inline void set_fs_state_arg_2(struct hmfs_checkpoint *hmfs_cp, u64 value)
./fs/hmfs/hmfs_fs.h:	hmfs_memcpy_atomic(&hmfs_cp->state_arg_2, &value, 8);
./fs/hmfs/hmfs_fs.h:static inline void set_fs_state(struct hmfs_checkpoint *hmfs_cp, u8 state)
./fs/hmfs/hmfs_fs.h:	set_fs_state_arg(hmfs_cp, 0);
./fs/hmfs/hmfs_fs.h:	hmfs_memcpy_atomic(&hmfs_cp->state, &state, 1);
./fs/hmfs/hmfs_fs.h:static inline struct hmfs_super_block *next_super_block(struct hmfs_super_block *raw_super)
./fs/hmfs/hmfs_fs.h:	unsigned int size = sizeof(struct hmfs_super_block);
./fs/hmfs/inode.c:#include "hmfs_fs.h"
./fs/hmfs/inode.c:#include "hmfs.h"
./fs/hmfs/inode.c:struct backing_dev_info hmfs_backing_dev_info __read_mostly = {
./fs/hmfs/inode.c:void hmfs_set_inode_flags(struct inode *inode)
./fs/hmfs/inode.c:int hmfs_convert_inline_inode(struct inode *inode)
./fs/hmfs/inode.c:	struct hmfs_inode *old_inode_block, *new_inode_block;
./fs/hmfs/inode.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/inode.c:	hmfs_bug_on(sbi, !is_inline_inode(inode));
./fs/hmfs/inode.c:	hmfs_bug_on(sbi, old_inode_block == new_inode_block);
./fs/hmfs/inode.c:	hmfs_memcpy(data_block, old_inode_block->inline_content, 
./fs/hmfs/inode.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/inode.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/inode.c:	struct hmfs_node *hn;
./fs/hmfs/inode.c:	struct hmfs_inode *hi;
./fs/hmfs/inode.c:	hn = (struct hmfs_node *)get_node(sbi, inode->i_ino);
./fs/hmfs/inode.c:	struct hmfs_inode_info *hi = HMFS_I(inode);
./fs/hmfs/inode.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/inode.c:	struct hmfs_inode_info *hi = HMFS_I(inode);
./fs/hmfs/inode.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/inode.c:int sync_hmfs_inode_size(struct inode *inode, bool force)
./fs/hmfs/inode.c:	struct hmfs_inode_info *inode_i = HMFS_I(inode);
./fs/hmfs/inode.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/inode.c:	struct hmfs_node *hn;
./fs/hmfs/inode.c:	struct hmfs_inode *hi;
./fs/hmfs/inode.c:int sync_hmfs_inode_proc(struct inode *inode, bool force)
./fs/hmfs/inode.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/inode.c:	struct hmfs_inode_info *inode_i = HMFS_I(inode);
./fs/hmfs/inode.c:	//struct hmfs_proc_info *proc= NULL;
./fs/hmfs/inode.c:	struct hmfs_node *hn;
./fs/hmfs/inode.c:	struct hmfs_inode *hi;
./fs/hmfs/inode.c:int sync_hmfs_inode(struct inode *inode, bool force)
./fs/hmfs/inode.c:	struct hmfs_sb_info *sbi = HMFS_SB(sb);
./fs/hmfs/inode.c:	struct hmfs_inode_info *inode_i = HMFS_I(inode);
./fs/hmfs/inode.c:	struct hmfs_node *rn;
./fs/hmfs/inode.c:	struct hmfs_inode *hi;
./fs/hmfs/inode.c:struct inode *hmfs_iget(struct super_block *sb, unsigned long ino)
./fs/hmfs/inode.c:	inode->i_mapping->backing_dev_info = &hmfs_backing_dev_info;
./fs/hmfs/inode.c:		inode->i_op = &hmfs_file_inode_operations;
./fs/hmfs/inode.c:		inode->i_fop = &hmfs_file_operations;
./fs/hmfs/inode.c:		inode->i_op = &hmfs_dir_inode_operations;
./fs/hmfs/inode.c:		inode->i_fop = &hmfs_dir_operations;
./fs/hmfs/inode.c:		inode->i_op = &hmfs_symlink_inode_operations;
./fs/hmfs/inode.c:		inode->i_op = &hmfs_special_inode_operations;
./fs/hmfs/inode.c:	//hmfs_dbg("[HMFS] : get inode #%lu\n", inode->i_ino);
./fs/hmfs/inode.c:const struct address_space_operations hmfs_aops_xip = {
./fs/hmfs/vmap.c:#include "hmfs.h"
./fs/hmfs/vmap.c:static pte_t *hmfs_pte_alloc_one_kernel(struct mm_struct *mm, unsigned long addr)
./fs/hmfs/vmap.c:static int __hmfs_pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)
./fs/hmfs/vmap.c:static pud_t *hmfs_pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long addr)
./fs/hmfs/vmap.c:	return (unlikely(pgd_none(*pgd)) && __hmfs_pud_alloc(mm, pgd, addr))?
./fs/hmfs/vmap.c:static int __hmfs_pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)
./fs/hmfs/vmap.c:static pmd_t *hmfs_pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)
./fs/hmfs/vmap.c:	return (unlikely(pud_none(*pud)) && __hmfs_pmd_alloc(mm, pud, address))?
./fs/hmfs/vmap.c:static pte_t *hmfs_pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)
./fs/hmfs/vmap.c:	new = hmfs_pte_alloc_one_kernel(mm, address);
./fs/hmfs/vmap.c:	pte_t *pte = hmfs_pte_alloc(mm, pmd, addr);
./fs/hmfs/vmap.c:	pmd = hmfs_pmd_alloc(mm, pud, addr);
./fs/hmfs/vmap.c:	pud = hmfs_pud_alloc(mm, pgd, addr);
./fs/hmfs/vmap.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/vmap.c:	hmfs_bug_on(sbi, end - start > 8);
./fs/hmfs/vmap.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/vmap.c:pte_t *hmfsp_pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)
./fs/hmfs/vmap.c:int _hmfsp__pte_alloc_kernel(pmd_t *pmd, unsigned long address)
./fs/hmfs/vmap.c:	pte_t *new = hmfsp_pte_alloc_one_kernel(imm, address);
./fs/hmfs/vmap.c:	pte = ((unlikely(pmd_none(*(pmd))) && _hmfsp__pte_alloc_kernel(pmd, addr))? NULL: pte_offset_kernel(pmd, addr));
./fs/hmfs/vmap.c:		// hmfs_dbg("[DP]addr:%lx,end:%lx\n",addr,end);
./fs/hmfs/vmap.c:int _hmfsp__pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)
./fs/hmfs/vmap.c:static inline pmd_t *hmfsp_pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)
./fs/hmfs/vmap.c:	return (unlikely(pud_none(*pud)) && _hmfsp__pmd_alloc(mm, pud, address))?
./fs/hmfs/vmap.c:	pmd = hmfsp_pmd_alloc(imm, pud, addr);
./fs/hmfs/vmap.c:int _hmfsp__pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)
./fs/hmfs/vmap.c:static inline pud_t *hmfsp_pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)
./fs/hmfs/vmap.c:	return (unlikely(pgd_none(*pgd)) && _hmfsp__pud_alloc(mm, pgd, address))?
./fs/hmfs/vmap.c:	pud = hmfsp_pud_alloc(imm, pgd, addr);
./fs/hmfs/vmap.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/vmap.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/vmap.c:	// 	hmfs_dbg("Out of range index:%lu end:%lu size:%lu\n", index, index+length-1,size>>HMFS_BLOCK_SIZE_BITS(blk_type));
./fs/hmfs/vmap.c:	if (full) hmfs_dbg("[Before vmap][A] Addr:%llx PageNumber:%llu\n", (unsigned long long)fi->rw_addr, (unsigned long long)fi->nr_map_page);
./fs/hmfs/vmap.c:		if (fi->rw_addr) hmfs_dbg("[Before vmap][B] Addr:%llx PageNumber:%llu\n", (unsigned long long)fi->rw_addr, (unsigned long long)fi->nr_map_page);
./fs/hmfs/vmap.c:		else hmfs_dbg("[Before vmap][C] Addr:%llx PageNumber:%llu\n", (unsigned long long)fi->rw_addr, (unsigned long long)fi->nr_map_page);
./fs/hmfs/vmap.c:	// hmfs_dbg("[DP]page:%llx index:%lld count:%lld pageoff:%lld\n",pages,index,length,offset);
./fs/hmfs/vmap.c:	// hmfs_dbg("[Pages]\n");
./fs/hmfs/vmap.c:	// for (i=0;i<length;++i)	hmfs_dbg("%llx\n",pages[i]);
./fs/hmfs/vmap.c:	hmfs_dbg("nrp %llu\n",fi->nr_map_page);
./fs/hmfs/vmap.c:		hmfs_dbg("[vmaping][B] remapped %d pages\n",ret);
./fs/hmfs/vmap.c:		hmfs_dbg("[After vmap][A] Addr:%llx PageNumber:%llu\n", (unsigned long long)fi->rw_addr, (unsigned long long)fi->nr_map_page);
./fs/hmfs/vmap.c:		hmfs_dbg("[After vmap][C] Addr:%llx PageNumber:%llu\n", (unsigned long long)fi->rw_addr, (unsigned long long)fi->nr_map_page);
./fs/hmfs/vmap.c:		hmfs_dbg("[After vmap][B] Addr:%llx PageNumber:%llu\n", (unsigned long long)fi->rw_addr, (unsigned long long)fi->nr_map_page);
./fs/hmfs/vmap.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/vmap.c:	// hmfs_dbg("[DP] ppos:%lu, len:%lu\n", ppos, ppos+len);
./fs/hmfs/vmap.c:	// hmfs_dbg("[DP] sizep:%lu pgstart:%lu, pgend:%lu, pglength:%lu\n", sizep, pgstart, pgend, pglength);
./fs/hmfs/vmap.c:int vmap_file_read_only_node_info(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/vmap.c:	struct inode *ino = hmfs_iget(sbi->sb, ni->ino);
./fs/hmfs/vmap.c:	struct hmfs_inode_info *fi = HMFS_I(ino);
./fs/hmfs/vmap.c:	struct hmfs_summary *summary = NULL;
./fs/hmfs/vmap.c:	hmfs_dbg("vmap count:%u pos:%llu isize:%llu",count,pos,isize);
./fs/hmfs/vmap.c:int vmap_file_read_only_node_info(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/vmap.c:	struct inode *ino = hmfs_iget(sbi->sb, ni->ino);
./fs/hmfs/vmap.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/vmap.c:	// hmfs_dbg("[Before unmap] Addr:%llx PageNumber:%llu\n", fi->rw_addr, fi->nr_map_page);
./fs/hmfs/vmap.c:	// hmfs_dbg("[After unmap] Addr:%llx PageNumber:%llu\n", fi->rw_addr, fi->nr_map_page);
./fs/hmfs/vmap.c:int unmap_file_read_only_node_info(struct hmfs_sb_info *sbi, struct node_info *ni){
./fs/hmfs/vmap.c:	struct inode *ino = hmfs_iget(sbi->sb, ni->ino);
./fs/hmfs/vmap.c:	struct hmfs_inode_info *fi = HMFS_I(ino);
./fs/hmfs/vmap.c:	hmfs_dbg("unmap Addr:%p count:%u pos:%llu isize:%llu",fi->rw_addr,count,pos,isize);
./fs/hmfs/vmap.c:	// hmfs_dbg("[Before unmap] Addr:%p PageNumber:%llu\n", fi->rw_addr, fi->nr_map_page);
./fs/hmfs/vmap.c:	// hmfs_dbg("pos:%lld, add:%d\n",pos,ADDRS_PER_BLOCK);
./fs/hmfs/vmap.c:	// hmfs_dbg("[After unmap] Addr:%p PageNumber:%llu\n", fi->rw_addr, fi->nr_map_page);
./fs/hmfs/namei.c: * fs/hmfs/namei.c
./fs/hmfs/namei.c:#include "hmfs.h"
./fs/hmfs/namei.c:#include "hmfs_fs.h"
./fs/hmfs/namei.c:static bool hmfs_may_set_inline_data(struct inode *dir)
./fs/hmfs/namei.c:static struct inode *hmfs_new_inode(struct inode *dir, umode_t mode)
./fs/hmfs/namei.c:	struct hmfs_sb_info *sbi = HMFS_SB(sb);
./fs/hmfs/namei.c:	struct hmfs_inode_info *i_info;
./fs/hmfs/namei.c:	if (hmfs_may_set_inline_data(dir)) {
./fs/hmfs/namei.c:	hmfs_bug_on(sbi, !IS_ERR(get_node(sbi, ino)));
./fs/hmfs/namei.c:	err = sync_hmfs_inode(inode, false);
./fs/hmfs/namei.c:struct inode *hmfs_make_dentry(struct inode *dir, struct dentry *dentry,
./fs/hmfs/namei.c:	struct hmfs_sb_info *sbi = HMFS_SB(sb);
./fs/hmfs/namei.c:	inode = hmfs_new_inode(dir, mode);
./fs/hmfs/namei.c:	err = hmfs_add_link(dentry, inode);
./fs/hmfs/namei.c:static int hmfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,
./fs/hmfs/namei.c:	inode = hmfs_make_dentry(dir, dentry, mode);
./fs/hmfs/namei.c:	inode->i_op = &hmfs_special_inode_operations;
./fs/hmfs/namei.c:static int hmfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
./fs/hmfs/namei.c:	inode = hmfs_make_dentry(dir, dentry, mode);
./fs/hmfs/namei.c:	inode->i_op = &hmfs_file_inode_operations;
./fs/hmfs/namei.c:	inode->i_fop = &hmfs_file_operations;
./fs/hmfs/namei.c:	inode->i_mapping->a_ops = &hmfs_aops_xip;
./fs/hmfs/namei.c:static int hmfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
./fs/hmfs/namei.c:	inode = hmfs_make_dentry(dir, dentry, S_IFDIR | mode);
./fs/hmfs/namei.c:	inode->i_op = &hmfs_dir_inode_operations;
./fs/hmfs/namei.c:	inode->i_fop = &hmfs_dir_operations;
./fs/hmfs/namei.c:	inode->i_mapping->a_ops = &hmfs_aops_xip;
./fs/hmfs/namei.c:static int hmfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)
./fs/hmfs/namei.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/namei.c:	err = hmfs_add_link(dentry, inode);
./fs/hmfs/namei.c:static int hmfs_unlink(struct inode *dir, struct dentry *dentry)
./fs/hmfs/namei.c:	struct hmfs_sb_info *sbi = HMFS_SB(sb);
./fs/hmfs/namei.c:	struct hmfs_dir_entry *de;
./fs/hmfs/namei.c:	struct hmfs_dentry_block *res_blk;
./fs/hmfs/namei.c:	de = hmfs_find_entry(dir, &dentry->d_name, &bidx, &ofs_in_blk);
./fs/hmfs/namei.c:	hmfs_delete_entry(de, res_blk, dir, inode, bidx);
./fs/hmfs/namei.c:static int hmfs_rmdir(struct inode *dir, struct dentry *dentry)
./fs/hmfs/namei.c:	if (hmfs_empty_dir(inode))
./fs/hmfs/namei.c:		return hmfs_unlink(dir, dentry);
./fs/hmfs/namei.c:static int hmfs_rename(struct inode *old_dir, struct dentry *old_dentry,
./fs/hmfs/namei.c:	struct hmfs_sb_info *sbi = HMFS_SB(sb);
./fs/hmfs/namei.c:	struct hmfs_dentry_block *old_dentry_blk, *new_dentry_blk;
./fs/hmfs/namei.c:	struct hmfs_dir_entry *old_dir_entry = NULL, *old_entry, *new_entry;
./fs/hmfs/namei.c:	old_entry = hmfs_find_entry(old_dir, &old_dentry->d_name, &old_bidx, &old_ofs);
./fs/hmfs/namei.c:		// .. in hmfs_dentry_block of old_inode
./fs/hmfs/namei.c:		old_dir_entry = hmfs_parent_dir(old_inode);
./fs/hmfs/namei.c:		if (old_dir_entry && !hmfs_empty_dir(new_inode))
./fs/hmfs/namei.c:		new_entry = hmfs_find_entry(new_dir, &new_dentry->d_name, &new_bidx,
./fs/hmfs/namei.c:		hmfs_set_link(new_dir, new_entry, old_inode);
./fs/hmfs/namei.c:		err = __hmfs_add_link(new_dir, &new_dentry->d_name, old_inode);
./fs/hmfs/namei.c:	hmfs_delete_entry(old_entry, old_dentry_blk, old_dir, NULL, old_bidx);
./fs/hmfs/namei.c:			hmfs_set_link(old_inode, old_dir_entry, new_dir);
./fs/hmfs/namei.c:int hmfs_getattr(struct vfsmount *mnt, struct dentry *dentry,
./fs/hmfs/namei.c:int hmfs_setattr(struct dentry *dentry, struct iattr *attr)
./fs/hmfs/namei.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/namei.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/namei.c:		hmfs_truncate(inode);
./fs/hmfs/namei.c:		acl = hmfs_get_acl(inode, ACL_TYPE_ACCESS);
./fs/hmfs/namei.c:				err = hmfs_set_acl(inode, acl, ACL_TYPE_ACCESS);
./fs/hmfs/namei.c:static struct dentry *hmfs_lookup(struct inode *dir, struct dentry *dentry,
./fs/hmfs/namei.c:	struct hmfs_dir_entry *de;
./fs/hmfs/namei.c:	de = hmfs_find_entry(dir, &dentry->d_name, NULL, NULL);
./fs/hmfs/namei.c:		inode = hmfs_iget(dir->i_sb, de->ino);
./fs/hmfs/namei.c:const struct inode_operations hmfs_dir_inode_operations = {
./fs/hmfs/namei.c:	.create = hmfs_create,
./fs/hmfs/namei.c:	.mkdir = hmfs_mkdir,
./fs/hmfs/namei.c:	.mknod = hmfs_mknod,
./fs/hmfs/namei.c:	.lookup = hmfs_lookup,
./fs/hmfs/namei.c:	.link = hmfs_link,
./fs/hmfs/namei.c:	.unlink = hmfs_unlink,
./fs/hmfs/namei.c:	.symlink = hmfs_symlink,
./fs/hmfs/namei.c:	.getattr = hmfs_getattr,
./fs/hmfs/namei.c:	.setattr = hmfs_setattr,
./fs/hmfs/namei.c:	.rmdir = hmfs_rmdir,
./fs/hmfs/namei.c:	.rename = hmfs_rename,
./fs/hmfs/namei.c:	.get_acl = hmfs_get_acl,
./fs/hmfs/namei.c:	.listxattr = hmfs_listxattr,
./fs/hmfs/namei.c:const struct inode_operations hmfs_special_inode_operations = {
./fs/hmfs/namei.c:	.getattr = hmfs_getattr,
./fs/hmfs/namei.c:	.setattr = hmfs_setattr,
./fs/hmfs/namei.c:	.get_acl = hmfs_get_acl,
./fs/hmfs/namei.c:	.listxattr = hmfs_listxattr,
./fs/hmfs/util.h:extern pte_t * (*hmfs_get_locked_pte) (struct mm_struct *, unsigned long, 
./fs/hmfs/segment.c:bool is_valid_address(struct hmfs_sb_info *sbi, block_t addr)
./fs/hmfs/segment.c:	struct hmfs_checkpoint *hmfs_cp = CM_I(sbi)->last_cp_i->cp;
./fs/hmfs/segment.c:		if (segno == le32_to_cpu(hmfs_cp->cur_segno[i]))
./fs/hmfs/segment.c:			return GET_SEG_OFS(sbi, addr) <= le32_to_cpu(hmfs_cp->cur_blkoff[i]);
./fs/hmfs/segment.c:unsigned long total_valid_blocks(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:void reset_new_segmap(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:				memset(se->invalid_bitmap, 0, hmfs_bitmap_size(allocator->nr_pages));
./fs/hmfs/segment.c:		hmfs_bug_on(sbi, write - read > allocator->buffer_index_mask);
./fs/hmfs/segment.c:unsigned long get_seg_vblocks_in_summary(struct hmfs_sb_info *sbi, seg_t segno)
./fs/hmfs/segment.c:	struct hmfs_summary *sum;
./fs/hmfs/segment.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/segment.c:int invalidate_delete_block(struct hmfs_sb_info *sbi, block_t addr, 
./fs/hmfs/segment.c:	struct hmfs_summary *summary;
./fs/hmfs/segment.c:static void init_min_max_mtime(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:void update_sit_entry(struct hmfs_sb_info *sbi, seg_t segno, int del)
./fs/hmfs/segment.c:	hmfs_dbg_on(new_vblocks < 0 || new_vblocks > SM_I(sbi)->segment_size >> HMFS_BLOCK_SIZE_BITS(0),
./fs/hmfs/segment.c:	hmfs_bug_on(sbi, new_vblocks < 0 || new_vblocks > 
./fs/hmfs/segment.c:inline block_t __cal_page_addr(struct hmfs_sb_info *sbi, seg_t segno, uint16_t blkoff)
./fs/hmfs/segment.c:static inline unsigned long cal_page_addr(struct hmfs_sb_info *sbi,	struct allocator *allocator)
./fs/hmfs/segment.c:int get_new_segment(struct hmfs_sb_info *sbi, seg_t *newseg)
./fs/hmfs/segment.c:	hmfs_bug_on(sbi, test_bit(segno, free_i->free_segmap));
./fs/hmfs/segment.c:static int move_to_new_segment(struct hmfs_sb_info *sbi, struct allocator *allocator)
./fs/hmfs/segment.c:	bitmap_size = hmfs_bitmap_size(allocator->nr_pages);
./fs/hmfs/segment.c:static block_t get_free_block(struct hmfs_sb_info *sbi, int seg_type, bool sit_lock)
./fs/hmfs/segment.c:						hmfs_collect_blocks(sbi);
./fs/hmfs/segment.c:		hmfs_bug_on(sbi, read > write);
./fs/hmfs/segment.c:inline block_t alloc_free_data_block(struct hmfs_sb_info *sbi, char seg_type)
./fs/hmfs/segment.c:inline block_t alloc_free_node_block(struct hmfs_sb_info *sbi, bool sit_lock)
./fs/hmfs/segment.c:void recovery_sit_entries(struct hmfs_sb_info *sbi, struct hmfs_checkpoint *hmfs_cp)
./fs/hmfs/segment.c:	struct hmfs_sit_log_entry *sit_log;
./fs/hmfs/segment.c:	struct hmfs_sit_entry *sit_entry;
./fs/hmfs/segment.c:	nr_logs = le16_to_cpu(hmfs_cp->nr_logs);
./fs/hmfs/segment.c:	nr_segs = hmfs_cp->nr_segs;
./fs/hmfs/segment.c:		sit_segno = le32_to_cpu(hmfs_cp->sit_logs[i]);
./fs/hmfs/segment.c:void flush_sit_entries_rmcp(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:	struct hmfs_sit_entry *sit_entry;
./fs/hmfs/segment.c:	struct hmfs_summary *summary;
./fs/hmfs/segment.c:void flush_sit_entries(struct hmfs_sb_info *sbi, block_t new_cp_addr,
./fs/hmfs/segment.c:	struct hmfs_sit_entry *sit_entry;
./fs/hmfs/segment.c:	struct hmfs_sit_log_entry *sit_log;
./fs/hmfs/segment.c:	struct hmfs_checkpoint *hmfs_cp = CM_I(sbi)->last_cp_i->cp;
./fs/hmfs/segment.c:	hmfs_bug_on(sbi, nrdirty != sit_i->dirty_sentries);
./fs/hmfs/segment.c:	sit_segno = le32_to_cpu(hmfs_cp->cur_segno[SEG_NODE_INDEX]);
./fs/hmfs/segment.c:		hmfs_cp->sit_logs[nr_segs--] = cpu_to_le32(sit_segno);
./fs/hmfs/segment.c:							le32_to_cpu(hmfs_cp->sit_logs[nr_segs]), 0);
./fs/hmfs/segment.c:	hmfs_cp->nr_logs = cpu_to_le16(nr_logs);
./fs/hmfs/segment.c:	hmfs_cp->nr_segs = nr_segs;
./fs/hmfs/segment.c:	set_fs_state_arg_2(hmfs_cp, new_cp_addr);
./fs/hmfs/segment.c:	set_fs_state(hmfs_cp, HMFS_ADD_CP);
./fs/hmfs/segment.c:static inline void __set_test_and_inuse(struct hmfs_sb_info *sbi,
./fs/hmfs/segment.c:static int build_sit_info(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/segment.c:	struct hmfs_checkpoint *hmfs_cp = cm_i->last_cp_i->cp;
./fs/hmfs/segment.c:	bitmap_size = hmfs_bitmap_size(TOTAL_SEGS(sbi));
./fs/hmfs/segment.c:	sit_i->elapsed_time = le32_to_cpu(hmfs_cp->elapsed_time);
./fs/hmfs/segment.c:void free_prefree_segments(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:static int build_free_segmap(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:	bitmap_size = hmfs_bitmap_size(TOTAL_SEGS(sbi));
./fs/hmfs/segment.c:static int build_allocators(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/segment.c:	struct hmfs_checkpoint *hmfs_cp = cm_i->last_cp_i->cp;
./fs/hmfs/segment.c:		array[i].next_blkoff = le32_to_cpu(hmfs_cp->cur_blkoff[i]);
./fs/hmfs/segment.c:		atomic_set(&array[i].segno, le32_to_cpu(hmfs_cp->cur_segno[i]));
./fs/hmfs/segment.c:static void build_sit_entries(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:	struct hmfs_sit_entry *sit_entry;
./fs/hmfs/segment.c:static void init_free_segmap(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:						hmfs_bitmap_size(allocator->nr_pages), GFP_KERNEL);
./fs/hmfs/segment.c:static void init_dirty_segmap(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:static int build_dirty_segmap(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:	dirty_i->dirty_segmap = kzalloc(hmfs_bitmap_size(TOTAL_SEGS(sbi)), GFP_KERNEL);
./fs/hmfs/segment.c:int build_segment_manager(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:	struct hmfs_super_block *raw_super = HMFS_RAW_SUPER(sbi);
./fs/hmfs/segment.c:	struct hmfs_sm_info *sm_info;
./fs/hmfs/segment.c:	sm_info = kzalloc(sizeof(struct hmfs_sm_info), GFP_KERNEL);
./fs/hmfs/segment.c:	sm_info->summary_block_size = sm_info->page_4k_per_seg * sizeof(struct hmfs_summary);
./fs/hmfs/segment.c:static void destroy_dirty_segmap(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:static void destroy_allocators(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:static void destroy_free_segmap(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:static void destroy_sit_info(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:				hmfs_bug_on(sbi, !test_bit(i, sit_i->new_segmap));
./fs/hmfs/segment.c:void destroy_segment_manager(struct hmfs_sb_info *sbi)
./fs/hmfs/segment.c:	struct hmfs_sm_info *sm_info = SM_I(sbi);
./fs/hmfs/segment.c:struct hmfs_summary *get_summary_block(struct hmfs_sb_info *sbi, seg_t segno)
./fs/hmfs/segment.c:struct hmfs_summary *get_summary_by_addr(struct hmfs_sb_info *sbi, block_t blk_addr)
./fs/hmfs/segment.c:struct hmfs_summary *get_summary_by_ni(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/xattr.h:#define XATTR_HDR(ptr)		((struct hmfs_xattr_header *)(ptr))
./fs/hmfs/xattr.h:#define XATTR_ENTRY(ptr)	((struct hmfs_xattr_entry *)(ptr))
./fs/hmfs/xattr.h:#define XATTR_RAW_SIZE			sizeof(struct hmfs_xattr_entry)
./fs/hmfs/xattr.h:#define XATTR_ENTRY_SIZE(entry)	(sizeof(struct hmfs_xattr_entry) + \
./fs/hmfs/xattr.h:struct hmfs_xattr_entry {
./fs/hmfs/xattr.h:struct hmfs_xattr_header {
./fs/hmfs/xattr.h:extern const struct xattr_handler hmfs_acl_access_handler;
./fs/hmfs/xattr.h:extern const struct xattr_handler hmfs_acl_default_handler;
./fs/hmfs/xattr.h:extern const struct xattr_handler *hmfs_xattr_handlers[];
./fs/hmfs/xattr.h:#define hmfs_xattr_handlers NULL
./fs/hmfs/proc.c:#include "hmfs.h"
./fs/hmfs/proc.c:#include "hmfs_fs.h"
./fs/hmfs/proc.c:static int update_proc_info(struct inode *inode, struct hmfs_proc_info *proc);
./fs/hmfs/proc.c:   	struct hmfs_proc_info *new_proc;// *proc = NULL;
./fs/hmfs/proc.c:   	//struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/proc.c:   	//struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/proc.c:   	//struct hmfs_nm_info *nm_i = NM_I(sbi);    
./fs/hmfs/proc.c:	new_proc = (struct hmfs_proc_info *)kzalloc(sizeof(struct hmfs_proc_info), GFP_KERNEL);
./fs/hmfs/proc.c:    	proc = list_entry(this, struct hmfs_proc_info, list);
./fs/hmfs/proc.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/proc.c:	//struct hmfs_nm_info *nm_i = sbi->nm_info;
./fs/hmfs/proc.c:	struct hmfs_summary *summary;
./fs/hmfs/proc.c:	ni = hmfs_get_node_info(inode,(int64_t)index);
./fs/hmfs/proc.c:static int update_proc_info(struct hmfs_nm_info *nm_i, struct hmfs_proc_info *c_proc){
./fs/hmfs/proc.c:	struct hmfs_proc_info *proc=NULL, *l_proc = NULL, *n_proc = NULL;
./fs/hmfs/proc.c:		proc = list_entry(this, struct hmfs_proc_info, list);
./fs/hmfs/proc.c:				l_proc = list_entry(this->prev, struct hmfs_proc_info, list);
./fs/hmfs/proc.c:static int update_proc_info(struct inode *inode, struct hmfs_proc_info *proc){
./fs/hmfs/proc.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/proc.c:	struct hmfs_inode_info *lfi = NULL;
./fs/hmfs/proc.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/proc.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/proc.c:	struct hmfs_proc_info *cur_proc, *pproc;
./fs/hmfs/proc.c:	hmfs_dbg("Insert proc id:%llu ino:%lu last:%lu\n",(unsigned long long)proc_id,inode->i_ino,last_visit_ino->i_ino);
./fs/hmfs/proc.c:struct hmfs_proc_info *fetch_proc(struct inode *inode, uint64_t proc_id){
./fs/hmfs/proc.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/proc.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/proc.c:	struct hmfs_nm_info *nm_i = sbi->nm_info;
./fs/hmfs/proc.c:	struct hmfs_proc_info *proc = NULL;
./fs/hmfs/acl.c: * fs/hmfs/acl.c
./fs/hmfs/acl.c:#include "hmfs_fs.h"
./fs/hmfs/acl.c:#include "hmfs.h"
./fs/hmfs/acl.c:static inline int hmfs_acl_count(size_t size)
./fs/hmfs/acl.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/acl.c:	struct hmfs_inode *inode_block;
./fs/hmfs/acl.c:static struct posix_acl *hmfs_read_acl(const char *base_addr, size_t size)
./fs/hmfs/acl.c:	struct hmfs_acl_entry *acl_entry = ACL_ENTRY(base_addr);
./fs/hmfs/acl.c:	count = hmfs_acl_count(size);
./fs/hmfs/acl.c:struct posix_acl *hmfs_get_acl(struct inode *inode, int type)
./fs/hmfs/acl.c:	struct hmfs_acl_header *acl_header = NULL;
./fs/hmfs/acl.c:	acl = hmfs_read_acl(entry, size);
./fs/hmfs/acl.c:	struct hmfs_acl_header *acl_header = ACL_HEADER(base_addr);
./fs/hmfs/acl.c:static void *hmfs_write_acl(struct inode *inode, const struct posix_acl *acl, int type)
./fs/hmfs/acl.c:	struct hmfs_acl_header *acl_header, *src_header;
./fs/hmfs/acl.c:	struct hmfs_acl_entry *entry;
./fs/hmfs/acl.c:	/* Skip sizeof(struct hmfs_acl_header) */
./fs/hmfs/acl.c:			hmfs_memcpy(entry, JUMP(src_header, ofs_default), cpy_size);
./fs/hmfs/acl.c:			hmfs_memcpy(entry, JUMP(src_header, ofs_access), cpy_size);
./fs/hmfs/acl.c:int hmfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
./fs/hmfs/acl.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/acl.c:	value = hmfs_write_acl(inode, acl, type);
./fs/hmfs/acl.c:static struct posix_acl *hmfs_acl_clone(const struct posix_acl *acl, gfp_t flags)
./fs/hmfs/acl.c:static int hmfs_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)
./fs/hmfs/acl.c:static int hmfs_acl_create(struct inode *dir, umode_t *mode,
./fs/hmfs/acl.c:	p = hmfs_get_acl(dir, ACL_TYPE_DEFAULT);
./fs/hmfs/acl.c:	clone = hmfs_acl_clone(p, GFP_NOFS);
./fs/hmfs/acl.c:	ret = hmfs_acl_create_masq(clone, mode);
./fs/hmfs/acl.c:int hmfs_init_acl(struct inode *inode, struct inode *dir)
./fs/hmfs/acl.c:	error = hmfs_acl_create(dir, &inode->i_mode, &default_acl, &acl);
./fs/hmfs/acl.c:		error = hmfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);
./fs/hmfs/acl.c:			error = hmfs_set_acl(inode, acl, ACL_TYPE_ACCESS);
./fs/hmfs/acl.c:size_t hmfs_acl_access_xattr_list(struct dentry *dentry, char *list, 
./fs/hmfs/acl.c:	struct hmfs_sb_info *sbi = HMFS_SB(dentry->d_sb);
./fs/hmfs/acl.c:size_t hmfs_acl_default_xattr_list(struct dentry *dentry, char *list,
./fs/hmfs/acl.c:	struct hmfs_sb_info *sbi = HMFS_SB(dentry->d_sb);
./fs/hmfs/acl.c:int hmfs_acl_xattr_get(struct dentry *dentry, const char *name, void *buffer,
./fs/hmfs/acl.c:	struct hmfs_sb_info *sbi = HMFS_SB(dentry->d_sb);
./fs/hmfs/acl.c:	acl = hmfs_get_acl(dentry->d_inode, type);
./fs/hmfs/acl.c:static int hmfs_acl_xattr_set(struct dentry *dentry, const char *name,
./fs/hmfs/acl.c:	struct hmfs_sb_info *sbi = HMFS_SB(dentry->d_sb);
./fs/hmfs/acl.c:	error = hmfs_set_acl(inode, acl, type);
./fs/hmfs/acl.c:const struct xattr_handler hmfs_acl_access_handler = {
./fs/hmfs/acl.c:	.list = hmfs_acl_access_xattr_list,
./fs/hmfs/acl.c:	.get = hmfs_acl_xattr_get,
./fs/hmfs/acl.c:	.set = hmfs_acl_xattr_set,
./fs/hmfs/acl.c:const struct xattr_handler hmfs_acl_default_handler = {
./fs/hmfs/acl.c:	.list = hmfs_acl_default_xattr_list,
./fs/hmfs/acl.c:	.get = hmfs_acl_xattr_get,
./fs/hmfs/acl.c:	.set = hmfs_acl_xattr_set,
./fs/hmfs/symlink.c:#include "hmfs_fs.h"
./fs/hmfs/symlink.c:#include "hmfs.h"
./fs/hmfs/symlink.c:int hmfs_symlink(struct inode *dir, struct dentry *dentry, const char *symname)
./fs/hmfs/symlink.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(dir);
./fs/hmfs/symlink.c:	inode = hmfs_make_dentry(dir, dentry, S_IFLNK | S_IRWXUGO);
./fs/hmfs/symlink.c:	inode->i_op = &hmfs_symlink_inode_operations;
./fs/hmfs/symlink.c:	inode->i_mapping->a_ops = &hmfs_aops_xip;
./fs/hmfs/symlink.c:	hmfs_memcpy(data_blk, (void *)symname, symlen);
./fs/hmfs/symlink.c:static int hmfs_readlink(struct dentry *dentry, char __user * buffer, int buflen)
./fs/hmfs/symlink.c:static void *hmfs_follow_link(struct dentry *dentry, struct nameidata *nd)
./fs/hmfs/symlink.c:const struct inode_operations hmfs_symlink_inode_operations = {
./fs/hmfs/symlink.c:	.readlink = hmfs_readlink,
./fs/hmfs/symlink.c:	.follow_link = hmfs_follow_link,
./fs/hmfs/symlink.c:	.getattr = hmfs_getattr,
./fs/hmfs/symlink.c:	.setattr = hmfs_setattr,
./fs/hmfs/symlink.c:	.get_acl = hmfs_get_acl,
./fs/hmfs/symlink.c:	.listxattr = hmfs_listxattr,
./fs/hmfs/hmfs.h:#include "hmfs_fs.h"
./fs/hmfs/hmfs.h:/* # of FS Lock in hmfs_sb_info */
./fs/hmfs/hmfs.h:/* used for hmfs_inode_info->flags */
./fs/hmfs/hmfs.h:struct hmfs_kthread {
./fs/hmfs/hmfs.h:	struct task_struct *hmfs_task;
./fs/hmfs/hmfs.h:struct hmfs_mmap_block {
./fs/hmfs/hmfs.h:struct hmfs_dentry_ptr {
./fs/hmfs/hmfs.h:	struct hmfs_dir_entry *dentry;
./fs/hmfs/hmfs.h:	struct hmfs_nat_node *nat_root;
./fs/hmfs/hmfs.h:	struct hmfs_checkpoint *cp;
./fs/hmfs/hmfs.h:struct hmfs_nm_info {
./fs/hmfs/hmfs.h:	struct hmfs_sb_info *sbi;
./fs/hmfs/hmfs.h:/* hmfs checkpoint manager */
./fs/hmfs/hmfs.h:struct hmfs_cm_info {
./fs/hmfs/hmfs.h:struct hmfs_sb_info {
./fs/hmfs/hmfs.h:	void *virt_addr;	/* hmfs_superblock & also HMFS address */
./fs/hmfs/hmfs.h:	struct hmfs_sit_entry *sit_entries;			/* Address of sit entries */
./fs/hmfs/hmfs.h:	struct hmfs_summary *ssa_entries;			/* Address of SSA entries */
./fs/hmfs/hmfs.h:	struct hmfs_cm_info *cm_info;				/* checkpoint manager */
./fs/hmfs/hmfs.h:	struct hmfs_stat_info *stat_info;			/* debug info manager */
./fs/hmfs/hmfs.h:	struct hmfs_nm_info *nm_info;				/* node manager */
./fs/hmfs/hmfs.h:	struct hmfs_sm_info *sm_info;				/* segment manager */
./fs/hmfs/hmfs.h:	struct hmfs_kthread *gc_thread;				/* GC thread */
./fs/hmfs/hmfs.h:	struct hmfs_kthread *warp_thread;	
./fs/hmfs/hmfs.h:struct hmfs_proc_info {
./fs/hmfs/hmfs.h:struct hmfs_inode_info {
./fs/hmfs/hmfs.h:	hmfs_hash_t chash;					/* hash value of given file name */
./fs/hmfs/hmfs.h:	/* Use below internally in hmfs */
./fs/hmfs/hmfs.h:	struct hmfs_inode *i_node_block;	/* HMFS inode on NVM */
./fs/hmfs/hmfs.h:        struct hmfs_proc_info i_proc_info[4];      /* process infomation*/
./fs/hmfs/hmfs.h:struct hmfs_stat_info {
./fs/hmfs/hmfs.h:	struct hmfs_sb_info *sbi;
./fs/hmfs/hmfs.h:	int nr_gc_try;			/* Time of call hmfs_gc */
./fs/hmfs/hmfs.h:	struct hmfs_node *node_block;
./fs/hmfs/hmfs.h:extern const struct file_operations hmfs_file_operations;
./fs/hmfs/hmfs.h:extern const struct file_operations hmfs_dir_operations;
./fs/hmfs/hmfs.h:extern const struct inode_operations hmfs_file_inode_operations;
./fs/hmfs/hmfs.h:extern const struct inode_operations hmfs_dir_inode_operations;
./fs/hmfs/hmfs.h:extern const struct inode_operations hmfs_symlink_inode_operations;
./fs/hmfs/hmfs.h:extern const struct inode_operations hmfs_special_inode_operations;
./fs/hmfs/hmfs.h:extern const struct address_space_operations hmfs_aops_xip;
./fs/hmfs/hmfs.h:static inline struct hmfs_super_block *HMFS_RAW_SUPER(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs.h:	return (struct hmfs_super_block *)(sbi->virt_addr);
./fs/hmfs/hmfs.h:static inline struct hmfs_inode_info *HMFS_I(struct inode *inode)
./fs/hmfs/hmfs.h:	return container_of(inode, struct hmfs_inode_info, vfs_inode);
./fs/hmfs/hmfs.h:static inline struct hmfs_nm_info *NM_I(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs.h:static inline int check_nid_range(struct hmfs_sb_info *sbi, nid_t nid)
./fs/hmfs/hmfs.h:static inline struct hmfs_sb_info *HMFS_SB(struct super_block *sb)
./fs/hmfs/hmfs.h:static inline struct hmfs_cm_info *CM_I(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs.h:static inline struct checkpoint_info *CURCP_I(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs.h:static inline void *ADDR(struct hmfs_sb_info *sbi, unsigned long logic_addr)
./fs/hmfs/hmfs.h:static inline block_t L_ADDR(struct hmfs_sb_info *sbi, void *ptr)
./fs/hmfs/hmfs.h:static inline struct hmfs_sb_info *HMFS_I_SB(struct inode *inode)
./fs/hmfs/hmfs.h:static inline struct hmfs_stat_info *STAT_I(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs.h:static inline void lock_free_nid(struct hmfs_nm_info *nm_i) 
./fs/hmfs/hmfs.h:static inline void unlock_free_nid(struct hmfs_nm_info *nm_i)
./fs/hmfs/hmfs.h:static inline void lock_cm(struct hmfs_cm_info *cm_i)
./fs/hmfs/hmfs.h:static inline void unlock_cm(struct hmfs_cm_info *cm_i)
./fs/hmfs/hmfs.h:static inline void lock_hmfs_stat(struct hmfs_stat_info *stat_i)
./fs/hmfs/hmfs.h:static inline void unlock_hmfs_stat(struct hmfs_stat_info *stat_i)
./fs/hmfs/hmfs.h:static inline void lock_read_nat(struct hmfs_nm_info *nm_i)
./fs/hmfs/hmfs.h:static inline void unlock_read_nat(struct hmfs_nm_info *nm_i)
./fs/hmfs/hmfs.h:static inline void lock_write_nat(struct hmfs_nm_info *nm_i)
./fs/hmfs/hmfs.h:static inline void unlock_write_nat(struct hmfs_nm_info *nm_i)
./fs/hmfs/hmfs.h:static inline void lock_orphan_inodes(struct hmfs_cm_info *cm_i)
./fs/hmfs/hmfs.h:static inline void unlock_orphan_inodes(struct hmfs_cm_info *cm_i)
./fs/hmfs/hmfs.h:static inline void lock_cp_tree(struct hmfs_cm_info *cm_i)
./fs/hmfs/hmfs.h:static inline void unlock_cp_tree(struct hmfs_cm_info *cm_i)
./fs/hmfs/hmfs.h:static inline void lock_gc(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs.h:static inline int trylock_gc(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs.h:static inline void unlock_gc(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs.h:static inline void lock_mmap(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs.h:static inline void unlock_mmap(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs.h:#define hmfs_dbg(fmt, ...) printk(KERN_INFO"%s-%d:"fmt, \
./fs/hmfs/hmfs.h:#define hmfs_dbg_on(condition, fmt, ...) 	\
./fs/hmfs/hmfs.h:#define hmfs_bug_on(sbi, condition)	\
./fs/hmfs/hmfs.h:#define hmfs_bug_on(sbi, condition)
./fs/hmfs/hmfs.h:#define hmfs_dbg(fmt, ...)
./fs/hmfs/hmfs.h:#define hmfs_dbg_on(condition, fmt, ...) 	
./fs/hmfs/hmfs.h:static inline struct kmem_cache *hmfs_kmem_cache_create(const char *name,
./fs/hmfs/hmfs.h:static inline int is_inode_flag_set(struct hmfs_inode_info *fi, int flag)
./fs/hmfs/hmfs.h:static inline void set_inode_flag(struct hmfs_inode_info *fi, int flag)
./fs/hmfs/hmfs.h:static inline void clear_inode_flag(struct hmfs_inode_info *fi, int flag)
./fs/hmfs/hmfs.h:static inline void set_acl_inode(struct hmfs_inode_info *fi, umode_t mode)
./fs/hmfs/hmfs.h:static inline void mutex_lock_all(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs.h:static inline u64 pfn_from_vaddr(struct hmfs_sb_info *sbi, void *vaddr)
./fs/hmfs/hmfs.h:static inline void mutex_unlock_all(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs.h:static inline int mutex_lock_op(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs.h:static inline void mutex_unlock_op(struct hmfs_sb_info *sbi, int ilock)
./fs/hmfs/hmfs.h:	hmfs_bug_on(sbi, ilock < 0 || ilock >= NR_GLOBAL_LOCKS);
./fs/hmfs/hmfs.h:static inline void dec_valid_inode_count(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs.h:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/hmfs.h:static inline bool inc_gc_block_count(struct hmfs_sb_info *sbi, int seg_type)
./fs/hmfs/hmfs.h:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/hmfs.h:static inline void inc_valid_inode_count(struct hmfs_sb_info *sbi)
./fs/hmfs/hmfs.h:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/hmfs.h:static inline loff_t hmfs_max_file_size(void)
./fs/hmfs/hmfs.h:static inline int hmfs_test_bit(unsigned int nr, char *addr)
./fs/hmfs/hmfs.h:static inline int hmfs_set_bit(unsigned int nr, char *addr)
./fs/hmfs/hmfs.h:static inline int hmfs_clear_bit(unsigned int nr, char *addr)
./fs/hmfs/hmfs.h:static inline int hmfs_readonly(struct super_block *sb)
./fs/hmfs/hmfs.h:static inline void make_dentry_ptr(struct hmfs_dentry_ptr *d, void *src, int normal_inode)
./fs/hmfs/hmfs.h:	struct hmfs_dentry_block *t = (struct hmfs_dentry_block *) src;
./fs/hmfs/hmfs.h:static inline void make_summary_entry(struct hmfs_summary *summary,
./fs/hmfs/hmfs.h:static inline nid_t get_summary_next_warp(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline nid_t get_summary_nid(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline unsigned int get_summary_offset(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline ver_t get_summary_start_version(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline unsigned char get_summary_type(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline int get_summary_valid_bit(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline void set_summary_nid(struct hmfs_summary *summary, nid_t nid)
./fs/hmfs/hmfs.h:static inline void set_summary_valid_bit(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->bt, &bt, 2);
./fs/hmfs/hmfs.h:static inline int get_warp_all(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline void set_warp_all(struct hmfs_summary *summary, int bt)
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->bt, &warp, 2);
./fs/hmfs/hmfs.h:static inline unsigned char get_warp_read_candidate(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline void set_warp_read_candidate_bit(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->bt, &bt, 2);
./fs/hmfs/hmfs.h:static inline void clear_warp_read_candidate_bit(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->bt, &bt, 2);
./fs/hmfs/hmfs.h:static inline unsigned char get_warp_write_candidate(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline void set_warp_write_candidate_bit(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->bt, &bt, 2);
./fs/hmfs/hmfs.h:static inline void clear_warp_write_candidate_bit(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->bt, &bt, 2);
./fs/hmfs/hmfs.h:static inline bool get_warp_read_pure(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline bool get_warp_write_pure(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline bool get_warp_is_read_candidate(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline bool get_warp_is_write_candidate(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline int get_warp_current_type(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline int get_warp_next_type(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline void reset_warp_read(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->bt, &bt, 2);
./fs/hmfs/hmfs.h:static inline void reset_warp_write(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->bt, &bt, 2);
./fs/hmfs/hmfs.h:static inline void reset_warp_normal(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->bt, &bt, 2);
./fs/hmfs/hmfs.h:static inline unsigned char get_warp_read(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline void set_warp_read_bit(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->bt, &bt, 2);
./fs/hmfs/hmfs.h:static inline void clear_warp_read_bit(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->bt, &bt, 2);
./fs/hmfs/hmfs.h:static inline unsigned char get_warp_write(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:static inline void set_warp_write_bit(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->bt, &bt, 2);
./fs/hmfs/hmfs.h:static inline void clear_warp_write_bit(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->bt, &bt, 2);
./fs/hmfs/hmfs.h:static inline void set_summary_type(struct hmfs_summary *summary, int type)
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->bt, &t, 2);
./fs/hmfs/hmfs.h:static inline void clear_summary_valid_bit(struct hmfs_summary *summary)
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->bt, &bt, 2);
./fs/hmfs/hmfs.h:static inline void set_summary_start_version(struct hmfs_summary *summary,
./fs/hmfs/hmfs.h:	hmfs_memcpy_atomic(&summary->start_version, &version, 4);
./fs/hmfs/hmfs.h:int __hmfs_write_inode(struct inode *inode, bool force);
./fs/hmfs/hmfs.h:int hmfs_sync_fs(struct super_block *sb, int sync);
./fs/hmfs/hmfs.h:struct inode *hmfs_iget(struct super_block *sb, unsigned long ino);
./fs/hmfs/hmfs.h:int sync_hmfs_inode(struct inode *inode, bool force);
./fs/hmfs/hmfs.h:int sync_hmfs_inode_proc(struct inode *inode, bool force);
./fs/hmfs/hmfs.h:int sync_hmfs_inode_size(struct inode *inode, bool force);
./fs/hmfs/hmfs.h:void hmfs_set_inode_flags(struct inode *inode);
./fs/hmfs/hmfs.h:int hmfs_convert_inline_inode(struct inode *inode);
./fs/hmfs/hmfs.h:int cleanup_wp_inode_entry(struct hmfs_sb_info *sbi, struct wp_nat_entry *wne);
./fs/hmfs/hmfs.h:int64_t hmfs_dir_seek_data_reverse(struct inode *dir, int64_t end_blk);
./fs/hmfs/hmfs.h:void hmfs_truncate(struct inode *inode);
./fs/hmfs/hmfs.h:int add_wp_node_info(struct hmfs_sb_info *sbi, struct node_info *ni);
./fs/hmfs/hmfs.h:int clean_wp_node_info(struct hmfs_sb_info *sbi, struct node_info *ni);
./fs/hmfs/hmfs.h:struct warp_candidate_entry *add_warp_candidate(struct hmfs_sb_info *sbi, struct node_info *ni);
./fs/hmfs/hmfs.h:struct warp_candidate_entry *add_warp_pending(struct hmfs_sb_info *sbi, struct node_info *ni);
./fs/hmfs/hmfs.h:struct node_info *pop_one_warp_pending_entry(struct hmfs_nm_info *nm_i);
./fs/hmfs/hmfs.h:long hmfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
./fs/hmfs/hmfs.h:int hmfs_sync_file(struct file *file, loff_t start, loff_t end, int datasync);
./fs/hmfs/hmfs.h:void hmfs_create_root_stat(void);
./fs/hmfs/hmfs.h:void hmfs_destroy_root_stat(void);
./fs/hmfs/hmfs.h:int hmfs_build_stats(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:void hmfs_destroy_stats(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:void update_nat_stat(struct hmfs_sb_info *, int count);
./fs/hmfs/hmfs.h:#define hmfs_destroy_stats(sbi)
./fs/hmfs/hmfs.h:#define hmfs_destroy_root_stat()
./fs/hmfs/hmfs.h:#define hmfs_build_stats(sbi) 	0
./fs/hmfs/hmfs.h:#define hmfs_create_root_stat()
./fs/hmfs/hmfs.h:int build_node_manager(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:void destroy_node_manager(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:int get_node_info(struct hmfs_sb_info *sbi, nid_t nid, struct node_info *ni);
./fs/hmfs/hmfs.h:struct node_info *get_node_info_by_nid(struct hmfs_sb_info *sbi, nid_t nid);
./fs/hmfs/hmfs.h:void *get_node(struct hmfs_sb_info *sbi, nid_t nid);
./fs/hmfs/hmfs.h:struct hmfs_node *__get_node(struct hmfs_sb_info *, struct checkpoint_info *, nid_t);
./fs/hmfs/hmfs.h:void alloc_nid_failed(struct hmfs_sb_info *, nid_t);
./fs/hmfs/hmfs.h:bool alloc_nid(struct hmfs_sb_info *, nid_t *);
./fs/hmfs/hmfs.h:void *alloc_new_node(struct hmfs_sb_info *, nid_t, struct inode *, char, bool);
./fs/hmfs/hmfs.h:void update_nat_entry(struct hmfs_nm_info *, nid_t, nid_t ino, block_t, bool);
./fs/hmfs/hmfs.h:struct hmfs_nat_node *flush_nat_entries(struct hmfs_sb_info *, struct hmfs_checkpoint *);
./fs/hmfs/hmfs.h:struct hmfs_nat_block *get_nat_entry_block(struct hmfs_sb_info *, ver_t, nid_t);
./fs/hmfs/hmfs.h:struct hmfs_nat_entry *get_nat_entry(struct hmfs_sb_info *, ver_t, nid_t);
./fs/hmfs/hmfs.h:struct hmfs_nat_node *get_nat_node(struct hmfs_sb_info *, ver_t, unsigned int);
./fs/hmfs/hmfs.h:void mark_block_valid(struct hmfs_sb_info *, struct hmfs_nat_node *, struct hmfs_checkpoint *);
./fs/hmfs/hmfs.h:int add_mmap_block(struct hmfs_sb_info *sbi, struct mm_struct *mm,
./fs/hmfs/hmfs.h:int remove_mmap_block(struct hmfs_sb_info *, struct mm_struct *, unsigned long);
./fs/hmfs/hmfs.h:int migrate_mmap_block(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:void gc_update_nat_entry(struct hmfs_nm_info *nm_i, nid_t nid, block_t blk_addr);
./fs/hmfs/hmfs.h:struct wp_nat_entry *init_wp_inode_entry(struct hmfs_nm_info *nm_i, struct inode *inode);
./fs/hmfs/hmfs.h:struct wp_nat_entry *search_wp_inode_entry_nid(struct hmfs_nm_info *nm_i, nid_t nid);
./fs/hmfs/hmfs.h:struct wp_nat_entry *search_wp_inode_entry(struct hmfs_nm_info *nm_i, struct inode *inode);
./fs/hmfs/hmfs.h:struct wp_data_page_entry *search_wp_data_block(struct hmfs_nm_info *nm_i, struct inode *inode, int index);
./fs/hmfs/hmfs.h:int add_wp_data_block(struct hmfs_nm_info *nm_i, struct inode *inode, int index, void *block);
./fs/hmfs/hmfs.h:int cleanup_all_wp_inode_entry(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:int delete_all_wp_inode_entry(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:void* hmfs_wp_wdp_write_back(struct inode *inode, struct wp_data_page_entry *wdp);
./fs/hmfs/hmfs.h:void* hmfs_wp_data_block_write_back(struct inode *inode, int index);
./fs/hmfs/hmfs.h:unsigned long total_valid_blocks(struct hmfs_sb_info *);
./fs/hmfs/hmfs.h:unsigned long get_seg_vblocks_in_summary(struct hmfs_sb_info *, seg_t);
./fs/hmfs/hmfs.h:void flush_sit_entries(struct hmfs_sb_info *sbi, block_t new_cp_addr, void *new_nat_root);
./fs/hmfs/hmfs.h:void recovery_sit_entries(struct hmfs_sb_info *sbi, struct hmfs_checkpoint *hmfs_cp);
./fs/hmfs/hmfs.h:int build_segment_manager(struct hmfs_sb_info *);
./fs/hmfs/hmfs.h:void destroy_segment_manager(struct hmfs_sb_info *);
./fs/hmfs/hmfs.h:struct hmfs_summary *get_summary_block(struct hmfs_sb_info *sbi, seg_t segno);
./fs/hmfs/hmfs.h:struct hmfs_summary *get_summary_by_addr(struct hmfs_sb_info *sbi, block_t blk_addr);
./fs/hmfs/hmfs.h:struct hmfs_summary *get_summary_by_ni(struct hmfs_sb_info *sbi, struct node_info *ni);
./fs/hmfs/hmfs.h:inline block_t alloc_free_data_block(struct hmfs_sb_info *sbi, char seg_type);
./fs/hmfs/hmfs.h:inline block_t alloc_free_node_block(struct hmfs_sb_info *sbi, bool sit_lock);
./fs/hmfs/hmfs.h:block_t __cal_page_addr(struct hmfs_sb_info *sbi, seg_t segno, uint16_t blkoff);
./fs/hmfs/hmfs.h:void update_sit_entry(struct hmfs_sb_info *sbi, seg_t, int);
./fs/hmfs/hmfs.h:void flush_sit_entries_rmcp(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:void free_prefree_segments(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:int get_new_segment(struct hmfs_sb_info *sbi, seg_t *newseg);
./fs/hmfs/hmfs.h:bool is_valid_address(struct hmfs_sb_info *sbi, block_t addr);
./fs/hmfs/hmfs.h:int invalidate_delete_block(struct hmfs_sb_info *sbi, block_t addr, unsigned long);
./fs/hmfs/hmfs.h:void reset_new_segmap(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:int recover_orphan_inodes(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:int init_checkpoint_manager(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:int destroy_checkpoint_manager(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:void add_orphan_inode(struct hmfs_sb_info *sbi, nid_t);
./fs/hmfs/hmfs.h:void remove_orphan_inode(struct hmfs_sb_info *sbi, nid_t);
./fs/hmfs/hmfs.h:int check_orphan_space(struct hmfs_sb_info *);
./fs/hmfs/hmfs.h:void display_warp(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:int write_checkpoint(struct hmfs_sb_info *sbi, bool unlock);
./fs/hmfs/hmfs.h:int redo_checkpoint(struct hmfs_sb_info *sbi, struct hmfs_checkpoint *prev_cp);
./fs/hmfs/hmfs.h:struct checkpoint_info *get_checkpoint_info(struct hmfs_sb_info *, ver_t version, bool);
./fs/hmfs/hmfs.h:struct checkpoint_info *get_next_checkpoint_info(struct hmfs_sb_info *sbi,
./fs/hmfs/hmfs.h:void check_checkpoint_state(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:int delete_checkpoint(struct hmfs_sb_info *sbi, ver_t version);
./fs/hmfs/hmfs.h:int redo_delete_checkpoint(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:void *alloc_new_data_block(struct hmfs_sb_info *sbi, struct inode *inode, int block);
./fs/hmfs/hmfs.h:int __hmfs_add_link(struct inode *, const struct qstr *, struct inode *);
./fs/hmfs/hmfs.h:struct hmfs_dir_entry *hmfs_find_entry(struct inode *, struct qstr *, int *, int *);
./fs/hmfs/hmfs.h:struct hmfs_dir_entry *hmfs_parent_dir(struct inode *);
./fs/hmfs/hmfs.h:void hmfs_set_link(struct inode *inode, struct hmfs_dir_entry *entry, struct inode *);
./fs/hmfs/hmfs.h:void hmfs_delete_entry(struct hmfs_dir_entry *, struct hmfs_dentry_block *,
./fs/hmfs/hmfs.h:int hmfs_make_empty(struct inode *, struct inode *);
./fs/hmfs/hmfs.h:bool hmfs_empty_dir(struct inode *);
./fs/hmfs/hmfs.h:struct hmfs_dentry_block *get_dentry_block_for_write(struct inode *dir, int old_bidx);
./fs/hmfs/hmfs.h:int hmfs_symlink(struct inode *inode, struct dentry *, const char *symname);
./fs/hmfs/hmfs.h:hmfs_hash_t hmfs_dentry_hash(const struct qstr *name_info);
./fs/hmfs/hmfs.h:int hmfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat);
./fs/hmfs/hmfs.h:int hmfs_setattr(struct dentry *dentry, struct iattr *attr);
./fs/hmfs/hmfs.h:struct inode *hmfs_make_dentry(struct inode *dir, struct dentry *dentry, umode_t mode);
./fs/hmfs/hmfs.h:int hmfs_fill_super(struct super_block *sb, void *data, int slient);
./fs/hmfs/hmfs.h:inline int hmfs_iounmap(void *virt_addr);
./fs/hmfs/hmfs.h:inline void destroy_map_zero_page(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:int vmap_file_read_only_node_info(struct hmfs_sb_info *sbi, struct node_info *ni);
./fs/hmfs/hmfs.h:int unmap_file_read_only_node_info(struct hmfs_sb_info *sbi, struct node_info *ni);
./fs/hmfs/hmfs.h:struct hmfs_proc_info *fetch_proc(struct inode *inode, uint64_t proc_id);
./fs/hmfs/hmfs.h:struct node_info *hmfs_get_node_info(struct inode *inode, int64_t index);
./fs/hmfs/hmfs.h:int hmfs_warp_type_range_update(struct file *filp, size_t len, loff_t *ppos, unsigned long type);
./fs/hmfs/hmfs.h:int hmfs_warp_update(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:inline void wake_up_warp(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:int start_warp_thread(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:void stop_warp_thread(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:struct node_info *find_next_warp_inter(struct hmfs_sb_info *sbi, struct node_info *ni);
./fs/hmfs/hmfs.h:inline struct node_info *find_next_warp_inner(struct hmfs_sb_info *sbi, struct node_info *ni);
./fs/hmfs/hmfs.h:inline void start_bc(struct hmfs_sb_info *);
./fs/hmfs/hmfs.h:void hmfs_collect_blocks(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:int hmfs_gc(struct hmfs_sb_info *sbi, int gc_type);
./fs/hmfs/hmfs.h:int start_gc_thread(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:void stop_gc_thread(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:int init_gc_logs(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:void reinit_gc_logs(struct hmfs_sb_info *sbi);
./fs/hmfs/hmfs.h:int init_gc_stat(struct hmfs_sb_info *);
./fs/hmfs/hmfs.h:void destroy_gc_stat(struct hmfs_sb_info *);
./fs/hmfs/hmfs.h:ssize_t hmfs_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size);
./fs/hmfs/hmfs.h:struct posix_acl *hmfs_get_acl(struct inode *inode, int type);
./fs/hmfs/hmfs.h:int hmfs_init_acl(struct inode *inode, struct inode *dir);
./fs/hmfs/hmfs.h:int hmfs_acl_xattr_get(struct dentry *, const char *name, void *buffer,
./fs/hmfs/hmfs.h:size_t hmfs_acl_access_xattr_list(struct dentry *, char *,
./fs/hmfs/hmfs.h:size_t hmfs_acl_default_xattr_list(struct dentry *, char *,
./fs/hmfs/hmfs.h:int hmfs_set_acl(struct inode *inode, struct posix_acl *acl, int type);
./fs/hmfs/hmfs.h:#define hmfs_get_acl(inode, type) 	NULL
./fs/hmfs/hmfs.h:#define hmfs_init_acl(inode, dir) 	0
./fs/hmfs/hmfs.h:#define hmfs_acl_xattr_get(dentry, name, buffer, size, type)	0
./fs/hmfs/hmfs.h:#define hmfs_acl_access_xattr_list(dentry, list, size, name, len, type)	0
./fs/hmfs/hmfs.h:#define hmfs_acl_default_xattr_list(dentry, list, size, name, len, type)	0
./fs/hmfs/hmfs.h:#define hmfs_set_acl(inode, acl, type)	0
./fs/hmfs/hmfs.h:void recovery_gc_crash(struct hmfs_sb_info *sbi, struct hmfs_checkpoint *hmfs_cp);
./fs/hmfs/hmfs.h:static inline int hmfs_add_link(struct dentry *dentry, struct inode *inode)
./fs/hmfs/hmfs.h:	ret = __hmfs_add_link(dir, &dentry->d_name,	inode);
./fs/hmfs/file.c: * fs/hmfs/file.c
./fs/hmfs/file.c:#include "hmfs_fs.h"
./fs/hmfs/file.c:#include "hmfs.h"
./fs/hmfs/file.c:static int dec_valid_block_count(struct hmfs_sb_info *sbi,
./fs/hmfs/file.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/file.c:int64_t hmfs_dir_seek_data_reverse(struct inode *dir, int64_t end_blk)
./fs/hmfs/file.c:	struct hmfs_inode *inode_block = NULL;
./fs/hmfs/file.c:	hmfs_bug_on(HMFS_I_SB(dir), is_inline_inode(dir));
./fs/hmfs/file.c:				hmfs_bug_on(HMFS_I_SB(dir), 1);
./fs/hmfs/file.c:			hmfs_bug_on(HMFS_I_SB(dir), !direct_node);
./fs/hmfs/file.c:			hmfs_bug_on(HMFS_I_SB(dir), !inode_block);
./fs/hmfs/file.c:	hmfs_bug_on(HMFS_I_SB(dir), 1);
./fs/hmfs/file.c:static unsigned int hmfs_file_seek_hole_data(struct inode *inode, 
./fs/hmfs/file.c:	struct hmfs_inode *inode_block = NULL;
./fs/hmfs/file.c:				hmfs_bug_on(HMFS_I_SB(inode), 1);
./fs/hmfs/file.c:			hmfs_bug_on(HMFS_I_SB(inode), !direct_node);
./fs/hmfs/file.c:			hmfs_bug_on(HMFS_I_SB(inode), !inode_block);
./fs/hmfs/file.c:static ssize_t __hmfs_xip_file_read(struct file *filp, char __user *buf,
./fs/hmfs/file.c:	// hmfs_dbg("Time B %llu\n", ktime_get().tv64);
./fs/hmfs/file.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/file.c:	struct hmfs_inode *inode_block;
./fs/hmfs/file.c:	struct hmfs_summary *summary;
./fs/hmfs/file.c:	// hmfs_dbg("Time C %llu\n", ktime_get().tv64);
./fs/hmfs/file.c:		ni = hmfs_get_node_info(inode, (int64_t)index);
./fs/hmfs/file.c:		// hmfs_dbg("[WARP Read] Inode:%lu index:[%lu,%lu]\n", inode->i_ino,index,index_hint);
./fs/hmfs/file.c:		// hmfs_dbg("[Normal Read] Inode:%lu index:%lu\n", inode->i_ino, index);
./fs/hmfs/file.c:		hmfs_bug_on(HMFS_I_SB(inode), nr > block_size);
./fs/hmfs/file.c:	// hmfs_dbg("Time D %llu\n", ktime_get().tv64);
./fs/hmfs/file.c:			// if (index>460 && index<470)hmfs_dbg("index:%ld offset:%ld buf:%p\n",index,offset,xip_mem + offset);
./fs/hmfs/file.c:			// if (index>972 && index<982)hmfs_dbg("index:%ld offset:%ld buf:%p\n",index,offset,xip_mem + offset);
./fs/hmfs/file.c:	// hmfs_dbg("Time E %llu\n", ktime_get().tv64);
./fs/hmfs/file.c:		// hmfs_dbg("copied:%lu, nr:%lu, left:%lu\n",copied,nr,left);
./fs/hmfs/file.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/file.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/file.c:int add_wp_node_info(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/file.c:	struct inode *ino = hmfs_iget(sbi->sb, ni->ino);
./fs/hmfs/file.c:	struct hmfs_inode_info *fi = HMFS_I(ino);
./fs/hmfs/file.c:	struct hmfs_node *hn = NULL;
./fs/hmfs/file.c:	struct hmfs_summary *summary = NULL;
./fs/hmfs/file.c:	//hmfs_dbg("addwp count:%u pos:%llu isize:%llu\n",count,pos,isize);
./fs/hmfs/file.c:			hmfs_dbg("data [%d] in %llx: len:%u\n",i,(unsigned long long)(char*)data,(unsigned int)strlen((char*)data));
./fs/hmfs/file.c:int clean_wp_node_info(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/file.c:	struct inode *ino = hmfs_iget(sbi->sb, ni->ino);
./fs/hmfs/file.c:	struct hmfs_inode_info *fi = HMFS_I(ino);
./fs/hmfs/file.c:	struct hmfs_summary *summary = NULL;
./fs/hmfs/file.c:	//hmfs_dbg("delwp count:%u pos:%llu isize:%llu",count,pos,isize);
./fs/hmfs/file.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/file.c:	hmfs_dbg("----------Entering debug test---------\n");
./fs/hmfs/file.c:	hmfs_dbg("page_size:%llu,blk_type:%d,isize:%llu,bits:%llu\n",page_size,blk_type,isize,bits);
./fs/hmfs/file.c:		hmfs_dbg("data [%d] in %llx: len:%u\n",i,(unsigned long long)(char*)data,(unsigned int)strlen((char*)data));
./fs/hmfs/file.c:		hmfs_dbg("%s\n",(char*)data);
./fs/hmfs/file.c:	hmfs_dbg("----------Leaving debug test----------\n");
./fs/hmfs/file.c: * Open file for hmfs, if it's a read-only file, then remap it into 
./fs/hmfs/file.c:int hmfs_file_open(struct inode *inode, struct file *filp)
./fs/hmfs/file.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/file.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/file.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/file.c:	hmfs_dbg("Open inode:%lu\n", filp->f_inode->i_ino);
./fs/hmfs/file.c:	// hmfs_dbg("Time %llu\n", kt.tv64);
./fs/hmfs/file.c:	// hmfs_dbg("Time %llu\n", kt.tv64);
./fs/hmfs/file.c:		hmfs_bug_on(HMFS_I_SB(inode), !fi->block_bitmap);
./fs/hmfs/file.c:	hmfs_bug_on(HMFS_I_SB(inode), fi->block_bitmap);
./fs/hmfs/file.c:static int hmfs_release_file(struct inode *inode, struct file *filp)
./fs/hmfs/file.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/file.c:	hmfs_dbg("Release inode:%lu\n", filp->f_inode->i_ino);
./fs/hmfs/file.c:	// hmfs_dbg("[After release] Addr:%llx PageNumber:%llu\n", (unsigned long long)fi->rw_addr, (unsigned long long)fi->nr_map_page);
./fs/hmfs/file.c:		ret = sync_hmfs_inode(inode, false);
./fs/hmfs/file.c:		ret = sync_hmfs_inode_size(inode, false);
./fs/hmfs/file.c:		ret = sync_hmfs_inode_proc(inode, false);
./fs/hmfs/file.c:static ssize_t hmfs_file_fast_read(struct file *filp, char __user *buf,
./fs/hmfs/file.c:static ssize_t hmfs_xip_file_read(struct file *filp, char __user *buf,
./fs/hmfs/file.c:	// hmfs_dbg("Time A %llu\n", ktime_get().tv64);
./fs/hmfs/file.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/file.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/file.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/file.c:	// hmfs_dbg("hmfs_xip_file_read() Inode:%lu, len:%lu, ppos:%lld\n", filp->f_inode->i_ino, len, *ppos);
./fs/hmfs/file.c:	// if (ret==0) hmfs_dbg("hmfs_xip_file_read() Successfully mapped\n");
./fs/hmfs/file.c:	// if (ret==1) hmfs_dbg("hmfs_xip_file_read() Not successfully mapped\n");
./fs/hmfs/file.c:	// if (ret==2) hmfs_dbg("hmfs_xip_file_read() No mapping at all\n");
./fs/hmfs/file.c:	//hmfs_dbg("[Read] Inode:%lu node No.%lu\n", filp->f_inode->i_ino, pgstart);
./fs/hmfs/file.c:	ret = __hmfs_xip_file_read(filp, buf, len, ppos);
./fs/hmfs/file.c:	if (false) 	ret = hmfs_file_fast_read(filp, buf, len, ppos);
./fs/hmfs/file.c:		if (is_fully_mapped_inode(filp->f_inode)) hmfs_dbg("[Full read] Inode:%lu\n", filp->f_inode->i_ino);
./fs/hmfs/file.c:		if (is_partially_mapped_inode(filp->f_inode)) hmfs_dbg("[Partial read] Inode:%lu node No.%lu\n", filp->f_inode->i_ino, pgstart);
./fs/hmfs/file.c:		ret = hmfs_file_fast_read(filp, buf, len, ppos);
./fs/hmfs/file.c:		// hmfs_dbg("[Normal read] Inode:%lu\n", filp->f_inode->i_ino);
./fs/hmfs/file.c:		hmfs_dbg("[Normal read] Inode:%lu node No.%lu\n", filp->f_inode->i_ino, pgstart);
./fs/hmfs/file.c:		ret = __hmfs_xip_file_read(filp, buf, len, ppos);
./fs/hmfs/file.c:	if(!sbi->turn_off_warp) hmfs_warp_type_range_update(filp, len, ppos, FLAG_WARP_READ);
./fs/hmfs/file.c:	// hmfs_dbg("Time F %llu\n", ktime_get().tv64);
./fs/hmfs/file.c:static ssize_t __hmfs_xip_file_write(struct inode *inode, const char __user *buf,
./fs/hmfs/file.c:	// struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/file.c:	struct hmfs_inode *inode_block;
./fs/hmfs/file.c:			status = hmfs_convert_inline_inode(inode);
./fs/hmfs/file.c:		// if (index>460 && index<470)hmfs_dbg("index:%ld offset:%ld buf:%p\n",index,offset,xip_mem + offset);
./fs/hmfs/file.c:		// if (index>972 && index<982)hmfs_dbg("index:%ld offset:%ld buf:%p\n",index,offset,xip_mem + offset);
./fs/hmfs/file.c:void* hmfs_wp_wdp_write_back(struct inode *inode, struct wp_data_page_entry *wdp) {
./fs/hmfs/file.c:void* hmfs_wp_data_block_write_back(struct inode *inode, int index) {
./fs/hmfs/file.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/file.c:	return hmfs_wp_wdp_write_back(inode, wdp);
./fs/hmfs/file.c:static ssize_t hmfs_file_fast_write(struct inode *inode, const char __user *buf,
./fs/hmfs/file.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/file.c:			return __hmfs_xip_file_write(inode, buf, len, ppos);
./fs/hmfs/file.c:				return __hmfs_xip_file_write(inode, buf, len, ppos);
./fs/hmfs/file.c: * hmfs_file_llseek - llseek implementation for in-memory files
./fs/hmfs/file.c:loff_t hmfs_file_llseek(struct file *file, loff_t offset, int whence)
./fs/hmfs/file.c:		pg_index = hmfs_file_seek_hole_data(inode, end_blk, offset, SEEK_DATA);
./fs/hmfs/file.c:		pg_index = hmfs_file_seek_hole_data(inode, end_blk, offset, SEEK_HOLE);
./fs/hmfs/file.c:ssize_t hmfs_xip_file_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)
./fs/hmfs/file.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/file.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/file.c:	if (true) ret = __hmfs_xip_file_write(inode, buf, count, ppos);
./fs/hmfs/file.c:	else ret = hmfs_file_fast_write(inode, buf, count, ppos);
./fs/hmfs/file.c:	// 	ret = hmfs_file_fast_write(inode, buf, count, ppos);
./fs/hmfs/file.c:	// 	ret = __hmfs_xip_file_write(inode, buf, count, ppos);
./fs/hmfs/file.c:	if(!sbi->turn_off_warp) hmfs_warp_type_range_update(filp, len, ppos, FLAG_WARP_WRITE);
./fs/hmfs/file.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(di->inode);
./fs/hmfs/file.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(di->inode);
./fs/hmfs/file.c:	struct hmfs_inode *inode_block;
./fs/hmfs/file.c:void hmfs_truncate(struct inode *inode)
./fs/hmfs/file.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/file.c:			ret = hmfs_convert_inline_inode(inode);
./fs/hmfs/file.c:			ret = hmfs_convert_inline_inode(inode);
./fs/hmfs/file.c:static int hmfs_get_mmap_block(struct inode *inode, pgoff_t index, 
./fs/hmfs/file.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/file.c:		hmfs_bug_on(sbi, !(vm_type & VM_READ));
./fs/hmfs/file.c:static void hmfs_filemap_close(struct vm_area_struct *vma)
./fs/hmfs/file.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/file.c:int add_mmap_block(struct hmfs_sb_info *sbi, struct mm_struct *mm,
./fs/hmfs/file.c:	struct hmfs_mmap_block *entry;
./fs/hmfs/file.c:int remove_mmap_block(struct hmfs_sb_info *sbi, struct mm_struct *mm,
./fs/hmfs/file.c:	struct hmfs_mmap_block *entry;
./fs/hmfs/file.c:		entry = list_entry(this, struct hmfs_mmap_block, list);
./fs/hmfs/file.c:int migrate_mmap_block(struct hmfs_sb_info *sbi)
./fs/hmfs/file.c:	struct hmfs_mmap_block *entry;
./fs/hmfs/file.c:		entry = list_entry(this, struct hmfs_mmap_block, list);
./fs/hmfs/file.c:		__cond_lock(ptl, pte = (*hmfs_get_locked_pte) (entry->mm, entry->vaddr,
./fs/hmfs/file.c:static int hmfs_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
./fs/hmfs/file.c:	// struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/file.c:	err = hmfs_get_mmap_block(inode, offset, &pfn, vma->vm_flags);
./fs/hmfs/file.c:		hmfs_bug_on(HMFS_I_SB(inode), err);
./fs/hmfs/file.c:static const struct vm_operations_struct hmfs_file_vm_ops = {
./fs/hmfs/file.c:	.close = hmfs_filemap_close,
./fs/hmfs/file.c:	.fault = hmfs_filemap_fault,
./fs/hmfs/file.c:static int hmfs_file_mmap(struct file *file, struct vm_area_struct *vma)
./fs/hmfs/file.c:	vma->vm_ops = &hmfs_file_vm_ops;
./fs/hmfs/file.c:int hmfs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)
./fs/hmfs/file.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/file.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/file.c:	if (hmfs_readonly(inode->i_sb))
./fs/hmfs/file.c:		ret = sync_hmfs_inode(inode, false);
./fs/hmfs/file.c:		ret = sync_hmfs_inode_size(inode, false);
./fs/hmfs/file.c:		ret = sync_hmfs_inode_size(inode, false);
./fs/hmfs/file.c:static long hmfs_fallocate(struct file *file, int mode, loff_t offset,
./fs/hmfs/file.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/file.c:static inline __u32 hmfs_mask_flags(umode_t mode, __u32 flags)
./fs/hmfs/file.c:long hmfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
./fs/hmfs/file.c:	struct hmfs_inode_info *fi = HMFS_I(inode);
./fs/hmfs/file.c:		flags = hmfs_mask_flags(inode->i_mode, flags);
./fs/hmfs/file.c:		hmfs_set_inode_flags(inode);
./fs/hmfs/file.c:long hmfs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
./fs/hmfs/file.c:	return hmfs_ioctl(file, cmd, (unsigned long) compat_ptr(arg));
./fs/hmfs/file.c:const struct file_operations hmfs_file_operations = {
./fs/hmfs/file.c:	.llseek = hmfs_file_llseek,
./fs/hmfs/file.c:	.read = hmfs_xip_file_read,
./fs/hmfs/file.c:	.write = hmfs_xip_file_write,
./fs/hmfs/file.c:	.open = hmfs_file_open,
./fs/hmfs/file.c:	.release = hmfs_release_file,
./fs/hmfs/file.c:	.mmap = hmfs_file_mmap,
./fs/hmfs/file.c:	.fsync = hmfs_sync_file,
./fs/hmfs/file.c:	.fallocate = hmfs_fallocate,
./fs/hmfs/file.c:	.unlocked_ioctl = hmfs_ioctl,
./fs/hmfs/file.c:	.compat_ioctl = hmfs_compat_ioctl,
./fs/hmfs/file.c:const struct inode_operations hmfs_file_inode_operations = {
./fs/hmfs/file.c:	.getattr = hmfs_getattr,
./fs/hmfs/file.c:	.setattr = hmfs_setattr,
./fs/hmfs/file.c:	.listxattr = hmfs_listxattr,
./fs/hmfs/file.c:	mmap_block_slab = hmfs_kmem_cache_create("hmfs_mmap_block",
./fs/hmfs/file.c:							sizeof(struct hmfs_mmap_block), NULL);
./fs/hmfs/data.c:#include "hmfs.h"
./fs/hmfs/data.c:static bool inc_valid_block_count(struct hmfs_sb_info *sbi,	struct inode *inode, int count)
./fs/hmfs/data.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/data.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/data.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(di->inode);
./fs/hmfs/data.c:	struct hmfs_inode *hi;
./fs/hmfs/data.c:	struct hmfs_inode_info* hii = HMFS_I(di->inode);
./fs/hmfs/data.c:	// struct node_info *ni = hmfs_get_node_info(&hii->vfs_inode, index);
./fs/hmfs/data.c:		ni = hmfs_get_node_info(&hii->vfs_inode, index);
./fs/hmfs/data.c:	// ni = hmfs_get_node_info(&hii->vfs_inode, index);
./fs/hmfs/data.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/data.c:	struct node_info *ni = hmfs_get_node_info(inode, index);
./fs/hmfs/data.c:			// hmfs_dbg("Get data block from wdg: inode:%u, index:%d.\n",nid,(int)index); 
./fs/hmfs/data.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/data.c:	hmfs_bug_on(sbi, start >= end);
./fs/hmfs/data.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/data.c:	struct hmfs_node *hn = NULL;
./fs/hmfs/data.c:	struct hmfs_summary *summary = NULL;
./fs/hmfs/data.c:	// 	hmfs_dbg("inside WRITEBACK\n");
./fs/hmfs/data.c:			// hmfs_dbg("WARP write ino:%lu block:%d\n",inode->i_ino,block);
./fs/hmfs/data.c:	// hmfs_dbg("PT write ino:%lu block:%d\n",inode->i_ino,block);
./fs/hmfs/data.c:		// hmfs_dbg("dest %llx;src %llx\n",(unsigned long long)dest,(unsigned long long)src);
./fs/hmfs/data.c:		// hmfs_dbg("%s\n",(char*)src);
./fs/hmfs/data.c:		// hmfs_dbg("%s\n",(char*)dest);
./fs/hmfs/data.c:			hmfs_memcpy(dest, src, HMFS_BLOCK_SIZE[seg_type]);
./fs/hmfs/data.c:				hmfs_memcpy(dest, src, pw_start);
./fs/hmfs/data.c:				hmfs_memcpy(dest + HMFS_BLOCK_SIZE[seg_type] - pw_end, src + HMFS_BLOCK_SIZE[seg_type] - pw_end, pw_end);
./fs/hmfs/data.c:void *alloc_new_data_block(struct hmfs_sb_info *sbi, struct inode *inode, 
./fs/hmfs/data.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/data.c:	struct hmfs_inode *inode_block;
./fs/hmfs/data.c:	struct hmfs_summary *summary = NULL;
./fs/hmfs/data.c:		hmfs_memcpy(dst, src, HMFS_BLOCK_SIZE[SEG_DATA_INDEX]);
./fs/hmfs/node.c:#include "hmfs.h"
./fs/hmfs/node.c:#include "hmfs_fs.h"
./fs/hmfs/node.c:const struct address_space_operations hmfs_nat_aops;
./fs/hmfs/node.c:static inline bool inc_valid_node_count(struct hmfs_sb_info *sbi, struct inode *inode,
./fs/hmfs/node.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/node.c:static inline void dec_valid_node_count(struct hmfs_sb_info *sbi, struct inode *inode,
./fs/hmfs/node.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/node.c:static nid_t hmfs_max_nid(struct hmfs_sb_info *sbi)
./fs/hmfs/node.c:static inline struct nat_entry *__lookup_nat_cache(struct hmfs_nm_info *nm_i, nid_t n)
./fs/hmfs/node.c:void destroy_node_manager(struct hmfs_sb_info *sbi)
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:	//hmfs_dbg("[WARP] : Deleting wp inode 0\n");
./fs/hmfs/node.c:	//hmfs_dbg("[WARP] : Deleting wp inode 1\n");
./fs/hmfs/node.c:static int init_node_manager(struct hmfs_sb_info *sbi)
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/node.c:	struct hmfs_checkpoint *cp = cp_i->cp;
./fs/hmfs/node.c:	nm_i->max_nid = hmfs_max_nid(sbi);
./fs/hmfs/node.c:void alloc_nid_failed(struct hmfs_sb_info *sbi, nid_t nid)
./fs/hmfs/node.c:static struct nat_entry *grab_nat_entry(struct hmfs_nm_info *nm_i, nid_t nid)
./fs/hmfs/node.c:	struct hmfs_sb_info *sbi = nm_i->sbi;
./fs/hmfs/node.c:	// hmfs_dbg("nid:%d ver:%u\n",nid,new->ni.begin_version);
./fs/hmfs/node.c:struct node_info *get_node_info_by_nid(struct hmfs_sb_info *sbi, nid_t nid){
./fs/hmfs/node.c:        //hmfs_dbg("[HMFS] : radix_tree_lookup misses.\n");
./fs/hmfs/node.c:struct warp_candidate_entry *add_warp_candidate(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/node.c:struct warp_candidate_entry *add_warp_pending(struct hmfs_sb_info *sbi, struct node_info *ni) {
./fs/hmfs/node.c:	struct hmfs_summary *summary = get_summary_by_addr(sbi, ni->blk_addr);
./fs/hmfs/node.c:struct node_info *pop_one_warp_pending_entry(struct hmfs_nm_info *nm_i) {
./fs/hmfs/node.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:		hmfs_bug_on(sbi, ni.blk_addr != 0);
./fs/hmfs/node.c:	hmfs_bug_on(sbi, ni.blk_addr == 0);
./fs/hmfs/node.c:struct hmfs_node *__get_node(struct hmfs_sb_info *sbi,
./fs/hmfs/node.c:	struct hmfs_nat_entry *nat_entry;
./fs/hmfs/node.c:	struct hmfs_summary *sum;
./fs/hmfs/node.c:		struct hmfs_checkpoint *hmfs_cp = cp_i->cp;
./fs/hmfs/node.c:			local_nid = le32_to_cpu(hmfs_cp->nat_journals[i].nid);
./fs/hmfs/node.c:				node_addr = le64_to_cpu(hmfs_cp->nat_journals[i].entry.block_addr);
./fs/hmfs/node.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/node.c:	hmfs_bug_on(sbi, !nid);
./fs/hmfs/node.c:			hmfs_bug_on(sbi, di.ofs_in_node >= ADDRS_PER_BLOCK);
./fs/hmfs/node.c:			hmfs_bug_on(sbi, di.ofs_in_node >= NIDS_PER_BLOCK);
./fs/hmfs/node.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/node.c:		struct hmfs_inode *hi = alloc_new_node(sbi, inode->i_ino, inode, SUM_TYPE_INODE, false);
./fs/hmfs/node.c:		hmfs_bug_on(sbi, !nid);
./fs/hmfs/node.c:void gc_update_nat_entry(struct hmfs_nm_info *nm_i, nid_t nid, block_t blk_addr)
./fs/hmfs/node.c:void update_nat_entry(struct hmfs_nm_info *nm_i, nid_t nid, nid_t ino,
./fs/hmfs/node.c:struct wp_nat_entry *init_wp_inode_entry(struct hmfs_nm_info *nm_i, struct inode *inode) {
./fs/hmfs/node.c:struct wp_nat_entry *search_wp_inode_entry_nid(struct hmfs_nm_info *nm_i, nid_t nid) {
./fs/hmfs/node.c:struct wp_nat_entry *search_wp_inode_entry(struct hmfs_nm_info *nm_i, struct inode *inode) {
./fs/hmfs/node.c:struct wp_data_page_entry *search_wp_data_block(struct hmfs_nm_info *nm_i, struct inode *inode, int index) {
./fs/hmfs/node.c:int add_wp_data_block(struct hmfs_nm_info *nm_i, struct inode *inode, int index, void *block) {
./fs/hmfs/node.c:	struct hmfs_sb_info *sbi = HMFS_I_SB(inode);
./fs/hmfs/node.c:int cleanup_wp_inode_entry(struct hmfs_sb_info *sbi, struct wp_nat_entry *wne) {
./fs/hmfs/node.c:	//hmfs_dbg("[HMFS] : Entered data block entry cleanup.\n");
./fs/hmfs/node.c:		// hmfs_dbg("Cleanup index: %d.\n",wdp->index);
./fs/hmfs/node.c:		ret = hmfs_wp_wdp_write_back(hmfs_iget(sbi->sb, wne->ino), wdp );
./fs/hmfs/node.c:int cleanup_one_wp_inode_entry(struct hmfs_sb_info *sbi, struct inode *inode) {
./fs/hmfs/node.c:int cleanup_all_wp_inode_entry(struct hmfs_sb_info *sbi) {
./fs/hmfs/node.c:	//hmfs_dbg("[HMFS] : Entered inode entry cleanup.\n");
./fs/hmfs/node.c:		//hmfs_dbg("[HMFS] : There are %d dirty inode entries this round.\n",count);
./fs/hmfs/node.c:			//hmfs_dbg("[HMFS] : Cleanup inode: %u.\n",wne[i]->ino);
./fs/hmfs/node.c:int delete_one_wp_inode_wdp_entry(struct hmfs_nm_info *nm_i, struct inode *inode, int index) {
./fs/hmfs/node.c:	//hmfs_dbg("Delete inode: %u.\n",wne->ino);
./fs/hmfs/node.c:			//hmfs_dbg("[WARP] : Release wdp:%llx\n", (unsigned long long)wdp);
./fs/hmfs/node.c:		//hmfs_dbg("[HMFS] : Delete index: %d.\n",wdp->index);
./fs/hmfs/node.c:		//hmfs_dbg("dbg1\n");
./fs/hmfs/node.c:		//hmfs_dbg("Release dp_addr:%llx\n",(unsigned long long)wdp->dp_addr);
./fs/hmfs/node.c:		//hmfs_dbg("dbg2\n");
./fs/hmfs/node.c:	//hmfs_dbg("[HMFS] : Last Release wdp:%llx\n",(unsigned long long)wdp);
./fs/hmfs/node.c:	//hmfs_dbg("[WARP] : dbg3\n");
./fs/hmfs/node.c:int delete_one_wp_inode_entry(struct hmfs_nm_info *nm_i, struct inode *inode) {
./fs/hmfs/node.c:int delete_all_wp_inode_entry(struct hmfs_sb_info *sbi) {
./fs/hmfs/node.c:		//hmfs_dbg("[WARP] : here are dirty inode entries after cleanup.\n");
./fs/hmfs/node.c:	//hmfs_dbg("[WARP] : Entered inode entry delete.\n");
./fs/hmfs/node.c:		//hmfs_dbg("[WARP] : There are %d inode entries this round.\n",count);
./fs/hmfs/node.c:			//hmfs_dbg("[WARP] : Deleting the %d th inode.\n",i);
./fs/hmfs/node.c:				//hmfs_dbg("[WARP] : Delete error with return %d.\n",ret);
./fs/hmfs/node.c:			//hmfs_dbg("[WARP] : Release wne:%llx\n",(unsigned long long)wne[i]);
./fs/hmfs/node.c:void *get_node(struct hmfs_sb_info *sbi, nid_t nid)
./fs/hmfs/node.c:static struct hmfs_node *__alloc_new_node(struct hmfs_sb_info *sbi, nid_t nid,
./fs/hmfs/node.c:	struct hmfs_node *dest;
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:	struct hmfs_summary *summary = NULL;
./fs/hmfs/node.c:		hmfs_memcpy(dest, src, HMFS_BLOCK_SIZE[SEG_NODE_INDEX]);
./fs/hmfs/node.c:		//hmfs_dbg("warpnid:%d,%u\n",warp,nid);
./fs/hmfs/node.c:void *alloc_new_node(struct hmfs_sb_info *sbi, nid_t nid, struct inode *inode,
./fs/hmfs/node.c:int get_node_info(struct hmfs_sb_info *sbi, nid_t nid, struct node_info *ni)
./fs/hmfs/node.c:	struct hmfs_nat_entry *ne_local;
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:	struct hmfs_summary *summary = NULL;
./fs/hmfs/node.c:	// hmfs_dbg("get_node_info:%d\n",nid);
./fs/hmfs/node.c:		// hmfs_dbg("[cache hit]\n");
./fs/hmfs/node.c:		// hmfs_dbg("[s1]%p\n",e);
./fs/hmfs/node.c:		// hmfs_dbg("[s0]%llu\n",e->ni.blk_addr);
./fs/hmfs/node.c:			// if (get_warp_read(summary)) hmfs_dbg("[ck] nid:%d Read is set.\n",nid);			
./fs/hmfs/node.c:			// if (get_warp_write(summary)) hmfs_dbg("[ck] nid:%d Write is set.\n",nid);
./fs/hmfs/node.c:			// hmfs_dbg("[s2]%p,%p,%d\n",e,summary,get_summary_valid_bit(summary));
./fs/hmfs/node.c:			// 	hmfs_dbg("[s3]%d\n",summary->next_warp);
./fs/hmfs/node.c:			// 	hmfs_dbg("Current:%d, Predicted:%d, PNext:%d, OnDisk:%d\n", nid, nm_i->predicted_nid, e->ni.next_warp, summary->next_warp);
./fs/hmfs/node.c:			// else hmfs_dbg("Current:%d, Predicted:%d, PNext:%d\n", nid, nm_i->predicted_nid, e->ni.next_warp);
./fs/hmfs/node.c:			// hmfs_dbg("[predict hit]\n");
./fs/hmfs/node.c:			// hmfs_dbg("[predict miss]\n");
./fs/hmfs/node.c:		// if((nm_i->hitcount)>0) hmfs_dbg("[predict] hit:%d, mis:%d\n", nm_i->hitcount, nm_i->miscount);
./fs/hmfs/node.c:		// hmfs_dbg("[predict]4\n");
./fs/hmfs/node.c:	// hmfs_dbg("[cache miss]\n");
./fs/hmfs/node.c:static inline void add_free_nid(struct hmfs_nm_info *nm_i, nid_t nid, u64 free,
./fs/hmfs/node.c:static void init_free_nids(struct hmfs_sb_info *sbi)
./fs/hmfs/node.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/node.c:	struct hmfs_checkpoint *hmfs_cp = cm_i->last_cp_i->cp;
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:		nid = le32_to_cpu(hmfs_cp->nat_journals[i].nid);
./fs/hmfs/node.c:		blk_addr = le64_to_cpu(hmfs_cp->nat_journals[i].entry.block_addr);
./fs/hmfs/node.c:static int is_valid_free_nid(struct hmfs_sb_info *sbi, nid_t nid)
./fs/hmfs/node.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:	struct hmfs_checkpoint *hmfs_cp = cm_i->last_cp_i->cp;
./fs/hmfs/node.c:		local_nid = le32_to_cpu(hmfs_cp->nat_journals[i].nid);
./fs/hmfs/node.c:static nid_t scan_nat_block(struct hmfs_sb_info *sbi, struct hmfs_nat_block *nat_blk,
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:static int scan_delete_nid(struct hmfs_sb_info *sbi, int *pos)
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:static int build_free_nids(struct hmfs_sb_info *sbi)
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:	struct hmfs_nat_block *nat_block = NULL;
./fs/hmfs/node.c:		hmfs_bug_on(sbi, nm_i->fcnt != count);
./fs/hmfs/node.c:bool alloc_nid(struct hmfs_sb_info *sbi, nid_t *nid)
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/node.c:	nat_entry_slab = hmfs_kmem_cache_create("hmfs_nat_entry",
./fs/hmfs/node.c:	warp_candidate_entry_slab = hmfs_kmem_cache_create("warp_candidate_entry",
./fs/hmfs/node.c:static void *__get_nat_page(struct hmfs_sb_info *sbi, block_t cur_node_addr,
./fs/hmfs/node.c:	struct hmfs_nat_node *cur_node;
./fs/hmfs/node.c:struct hmfs_nat_block *get_nat_entry_block(struct hmfs_sb_info *sbi,
./fs/hmfs/node.c:	struct hmfs_nat_node *nat_root = cp_i->nat_root;
./fs/hmfs/node.c:	hmfs_bug_on(sbi, !cp_i);
./fs/hmfs/node.c:struct hmfs_nat_entry *get_nat_entry(struct hmfs_sb_info *sbi,
./fs/hmfs/node.c:	struct hmfs_nat_block *nat_block;
./fs/hmfs/node.c:struct hmfs_nat_node *get_nat_node(struct hmfs_sb_info *sbi,
./fs/hmfs/node.c:	struct hmfs_nat_node *nat_root = cp_i->nat_root;
./fs/hmfs/node.c:	hmfs_bug_on(sbi, !cp_i);
./fs/hmfs/node.c:static block_t __flush_nat_entries(struct hmfs_sb_info *sbi,
./fs/hmfs/node.c:				struct hmfs_nat_node *old_nat_node, 
./fs/hmfs/node.c:				struct hmfs_nat_node *cur_nat_node,	unsigned int blk_order,
./fs/hmfs/node.c:	struct hmfs_nat_node *cur_stored_node, *old_child_node = NULL, 
./fs/hmfs/node.c:	struct hmfs_summary *summary;
./fs/hmfs/node.c:		hmfs_bug_on(sbi, IS_ERR(cur_stored_node) || !cur_stored_node);
./fs/hmfs/node.c:		hmfs_bug_on(sbi, !nat_entry_page);
./fs/hmfs/node.c:		hmfs_memcpy(cur_stored_node, nat_entry_page, HMFS_BLOCK_SIZE[SEG_NODE_INDEX]);
./fs/hmfs/node.c:		hmfs_bug_on(sbi, IS_ERR(cur_stored_node) || !cur_stored_node);
./fs/hmfs/node.c:			hmfs_memcpy(cur_stored_node, old_nat_node, HMFS_BLOCK_SIZE[SEG_NODE_INDEX]);
./fs/hmfs/node.c:static void clean_free_nid(struct hmfs_sb_info *sbi, nid_t nid)
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:	hmfs_bug_on(sbi, 1);
./fs/hmfs/node.c:static inline void clean_dirty_nat_entries(struct hmfs_sb_info *sbi) 
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:static void cache_nat_journals_entries(struct hmfs_sb_info *sbi)
./fs/hmfs/node.c:	struct hmfs_checkpoint *hmfs_cp = CM_I(sbi)->last_cp_i->cp;
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/node.c:	struct hmfs_nat_journal *ne;
./fs/hmfs/node.c:		ne = &hmfs_cp->nat_journals[i];
./fs/hmfs/node.c:int build_node_manager(struct hmfs_sb_info *sbi)
./fs/hmfs/node.c:	struct hmfs_nm_info *info;
./fs/hmfs/node.c:	info = kzalloc(sizeof(struct hmfs_nm_info), GFP_KERNEL);
./fs/hmfs/node.c:static int __flush_nat_journals(struct hmfs_checkpoint *hmfs_cp, 
./fs/hmfs/node.c:	struct hmfs_nat_journal *nat_journal;
./fs/hmfs/node.c:	nat_journal = &hmfs_cp->nat_journals[*journal_pos];
./fs/hmfs/node.c: * Caller should obtain hmfs_nm_info.nat_tree_lock.
./fs/hmfs/node.c:static void flush_nat_journals(struct hmfs_sb_info *sbi, 
./fs/hmfs/node.c:				struct hmfs_checkpoint *hmfs_cp)
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/node.c:				full = __flush_nat_journals(hmfs_cp, entry, nr_dirty_nat,
./fs/hmfs/node.c:struct hmfs_nat_node *flush_nat_entries(struct hmfs_sb_info *sbi,
./fs/hmfs/node.c:				struct hmfs_checkpoint *hmfs_cp)
./fs/hmfs/node.c:	struct hmfs_nat_node *old_root_node, *new_root_node;
./fs/hmfs/node.c:	struct hmfs_nat_block *old_entry_block, *new_entry_block;
./fs/hmfs/node.c:	struct hmfs_summary *summary;
./fs/hmfs/node.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/node.c:	struct hmfs_nm_info *nm_i = NM_I(sbi);
./fs/hmfs/node.c:	flush_nat_journals(sbi, hmfs_cp);
./fs/hmfs/node.c:		hmfs_memcpy(new_entry_block, old_entry_block, HMFS_BLOCK_SIZE[SEG_NODE_INDEX]);
./fs/hmfs/node.c:	hmfs_bug_on(sbi,new_root_node==NULL || new_root_node == old_root_node);
./fs/hmfs/node.c:void mark_block_valid_type(struct hmfs_sb_info *sbi, block_t addr)
./fs/hmfs/node.c:	struct hmfs_summary *summary;
./fs/hmfs/node.c:		struct hmfs_inode *hi = ADDR(sbi, addr);
./fs/hmfs/node.c:static void __mark_block_valid(struct hmfs_sb_info *sbi,	 
./fs/hmfs/node.c:				struct hmfs_nat_node *cur_nat_node, unsigned int blk_order,
./fs/hmfs/node.c:	struct hmfs_nat_node *cur_child_node = NULL;
./fs/hmfs/node.c:	struct hmfs_nat_block *nat_entry_blk = NULL;
./fs/hmfs/node.c:	struct hmfs_summary *raw_summary;
./fs/hmfs/node.c:		hmfs_bug_on(sbi, get_summary_type(raw_summary) != SUM_TYPE_NATD);
./fs/hmfs/node.c:void mark_block_valid(struct hmfs_sb_info *sbi, struct hmfs_nat_node *nat_root,
./fs/hmfs/node.c:				struct hmfs_checkpoint *hmfs_cp)
./fs/hmfs/node.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/node.c:	struct hmfs_nat_journal *nat_journal;
./fs/hmfs/node.c:	nat_journal = hmfs_cp->nat_journals;
./fs/hmfs/node.c:		sto_version = le32_to_cpu(hmfs_cp->checkpoint_ver);
./fs/hmfs/gc.c:#include "hmfs.h"
./fs/hmfs/gc.c:#include "hmfs_fs.h"
./fs/hmfs/gc.c:void prepare_move_argument(struct gc_move_arg *arg,	struct hmfs_sb_info *sbi, seg_t mv_segno,
./fs/hmfs/gc.c:	hmfs_bug_on(sbi, IS_ERR(arg->dest));
./fs/hmfs/gc.c:	hmfs_memcpy(arg->dest, arg->src, HMFS_BLOCK_SIZE[type]);
./fs/hmfs/gc.c:static unsigned int get_gc_cost(struct hmfs_sb_info *sbi, unsigned int segno,
./fs/hmfs/gc.c:		hmfs_bug_on(sbi, 1);
./fs/hmfs/gc.c:static void set_victim_policy(struct hmfs_sb_info *sbi, struct victim_info *p, int gc_type)
./fs/hmfs/gc.c:static int get_victim(struct hmfs_sb_info *sbi, struct victim_info *vi, int gc_type) // MZX : unused parameter : gc_type!
./fs/hmfs/gc.c:		hmfs_bug_on(sbi, get_valid_blocks(sbi, segno) == SM_I(sbi)->page_4k_per_seg);
./fs/hmfs/gc.c:		hmfs_dbg("[GC] : search victim segment # segno = %lu, gc_cost = %lu\n",(unsigned long)segno, cost);
./fs/hmfs/gc.c:	hmfs_dbg("[GC] : Select victim : %d\n", vi->min_segno);
./fs/hmfs/gc.c:static void update_dest_summary(struct hmfs_summary *src_sum, struct hmfs_summary *dest_sum)
./fs/hmfs/gc.c:	hmfs_memcpy(dest_sum, src_sum, sizeof(struct hmfs_summary));
./fs/hmfs/gc.c:static void move_data_block(struct hmfs_sb_info *sbi, seg_t src_segno, unsigned src_off, 
./fs/hmfs/gc.c:	struct hmfs_node *last = NULL, *this = NULL;
./fs/hmfs/gc.c:	struct hmfs_summary *par_sum = NULL;
./fs/hmfs/gc.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/gc.c:		hmfs_dbg_on(get_summary_type(par_sum) != SUM_TYPE_INODE &&
./fs/hmfs/gc.c:		hmfs_bug_on(sbi, get_summary_type(par_sum) != SUM_TYPE_INODE &&
./fs/hmfs/gc.c:			hmfs_memcpy_atomic(&this->i.i_addr[args.ofs_in_node], &args.dest_addr, 8);
./fs/hmfs/gc.c:			hmfs_memcpy_atomic(&this->dn.addr[args.ofs_in_node], &args.dest_addr, 8);
./fs/hmfs/gc.c:static void recycle_segment(struct hmfs_sb_info *sbi, seg_t segno, bool none_valid)
./fs/hmfs/gc.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/gc.c:		hmfs_bug_on(sbi, 1);
./fs/hmfs/gc.c:			hmfs_bug_on(sbi, 1);
./fs/hmfs/gc.c:static void move_xdata_block(struct hmfs_sb_info *sbi, seg_t src_segno,	unsigned src_off,
./fs/hmfs/gc.c:	struct hmfs_node *last = NULL, *this = NULL;
./fs/hmfs/gc.c:	struct hmfs_cm_info *cm_i = CM_I(sbi);
./fs/hmfs/gc.c:		hmfs_bug_on(sbi, get_summary_type(get_summary_by_addr(sbi, L_ADDR(sbi, this)))
./fs/hmfs/gc.c:		hmfs_memcpy_atomic(JUMP(this, x_tag), &arg.dest_addr, 8);
./fs/hmfs/gc.c:static void move_node_block(struct hmfs_sb_info *sbi, seg_t src_segno, unsigned src_off,
./fs/hmfs/gc.c:	struct hmfs_nat_block *last = NULL, *this = NULL;
./fs/hmfs/gc.c:		hmfs_memcpy_atomic(&this->entries[args.ofs_in_node].block_addr,	&args.dest_addr, 8);
./fs/hmfs/gc.c:static void move_nat_block(struct hmfs_sb_info *sbi, seg_t src_segno, int src_off,
./fs/hmfs/gc.c:	struct hmfs_checkpoint *hmfs_cp;
./fs/hmfs/gc.c:	struct hmfs_nat_node *nat_node;
./fs/hmfs/gc.c:		hmfs_bug_on(sbi, !this);
./fs/hmfs/gc.c:			hmfs_cp = HMFS_CHECKPOINT(this);
./fs/hmfs/gc.c:			addr_in_par = le64_to_cpu(hmfs_cp->nat_addr);
./fs/hmfs/gc.c:			hmfs_memcpy_atomic(&hmfs_cp->nat_addr, &args.dest_addr, 8);
./fs/hmfs/gc.c:			hmfs_memcpy_atomic(&nat_node->addr[args.ofs_in_node], &args.dest_addr, 8);
./fs/hmfs/gc.c:static void move_orphan_block(struct hmfs_sb_info *sbi, seg_t src_segno, int src_off,
./fs/hmfs/gc.c:	struct hmfs_checkpoint *hmfs_cp;
./fs/hmfs/gc.c:	hmfs_cp = ADDR(sbi, cp_addr);
./fs/hmfs/gc.c:	hmfs_cp->orphan_addrs[get_summary_offset(args.src_sum)] = cpu_to_le64(args.dest_addr);
./fs/hmfs/gc.c:static void move_checkpoint_block(struct hmfs_sb_info *sbi, seg_t src_segno,
./fs/hmfs/gc.c:	struct hmfs_checkpoint *prev_cp, *next_cp, *this_cp;
./fs/hmfs/gc.c:	hmfs_bug_on(sbi, !cp_i);
./fs/hmfs/gc.c:	hmfs_memcpy_atomic(&next_cp->prev_cp_addr, &args.dest_addr, 8);
./fs/hmfs/gc.c:	hmfs_memcpy_atomic(&prev_cp->next_cp_addr, &args.dest_addr, 8);
./fs/hmfs/gc.c:		hmfs_memcpy_atomic(orphan, &args.dest_addr, 8);
./fs/hmfs/gc.c:static void get_buddy_segment(struct hmfs_sb_info *sbi, struct victim_info *vi)
./fs/hmfs/gc.c:	//struct hmfs_summary *v_sum = NULL;
./fs/hmfs/gc.c:		hmfs_dbg("[GC] : search buddy segment # segno = %lu, gc_cost = %d\n", (unsigned long)segno, temp_value);
./fs/hmfs/gc.c:		hmfs_dbg("[GC] : alloc a new segment as the buddy segment # segno = %lu\n", (unsigned long)vi->buddy_segno);
./fs/hmfs/gc.c:static void garbage_collect(struct hmfs_sb_info *sbi, struct victim_info *vi)
./fs/hmfs/gc.c:	struct hmfs_summary *d_sum, *s_sum;
./fs/hmfs/gc.c:		hmfs_bug_on(sbi, vi->buddy_segno == NULL_SEGNO);
./fs/hmfs/gc.c:		hmfs_dbg("[GC] : found buddy segment : segno = %lu\n", (unsigned long)d_segno);
./fs/hmfs/gc.c:					hmfs_bug_on(sbi, vi->buddy_segno == NULL_SEGNO);
./fs/hmfs/gc.c:					hmfs_dbg("[GC] : found buddy segment : segno = %lu\n", (unsigned long)d_segno);
./fs/hmfs/gc.c:		hmfs_dbg("[GC] : move block from (%lu, %d) to (%lu, %d)\n", (unsigned long)s_segno, s_off, (unsigned long)d_segno, d_off);
./fs/hmfs/gc.c:			hmfs_bug_on(sbi, 1);
./fs/hmfs/gc.c:int hmfs_gc(struct hmfs_sb_info *sbi, int gc_type) // MZX : gc_type : BG_GC or FG_GC
./fs/hmfs/gc.c:	struct hmfs_checkpoint *hmfs_cp = CM_I(sbi)->last_cp_i->cp;
./fs/hmfs/gc.c:	hmfs_dbg("[GC] : Enter GC, gc_type = %s\n", gc_type == BG_GC ? "BG_GC" : "FG_GC");
./fs/hmfs/gc.c:	if (hmfs_cp->state == HMFS_NONE) // MZX : else ?
./fs/hmfs/gc.c:		set_fs_state(hmfs_cp, HMFS_GC);
./fs/hmfs/gc.c:	hmfs_dbg("[GC] : Before get victim:%ld %ld %ld\n", (unsigned long)total_valid_blocks(sbi),
./fs/hmfs/gc.c:	hmfs_dbg("[GC] : GC Victim: segno = %d, valid blocks = %d\n", (int)vi.min_segno, get_valid_blocks(sbi, vi.min_segno));
./fs/hmfs/gc.c:		hmfs_memcpy_atomic(sbi->gc_logs, &vi.min_segno, 4);		
./fs/hmfs/gc.c:		hmfs_memcpy_atomic(&hmfs_cp->nr_gc_segs, &sbi->nr_gc_segs, 4);
./fs/hmfs/gc.c:	hmfs_bug_on(sbi, total_valid_blocks(sbi) != CM_I(sbi)->valid_block_count);
./fs/hmfs/gc.c:	hmfs_dbg("[GC] : GC:%ld %ld %ld\n", (unsigned long)total_valid_blocks(sbi),
./fs/hmfs/gc.c:	hmfs_bug_on(sbi, total_valid_blocks(sbi) != CM_I(sbi)->valid_block_count);
./fs/hmfs/gc.c:		hmfs_bug_on(sbi, ret);
./fs/hmfs/gc.c:		hmfs_dbg("[GC] : Write checkpoint done\n");
./fs/hmfs/gc.c:	hmfs_dbg("[GC] : Exit GC:%ld %ld %ld\n", (unsigned long)total_valid_blocks(sbi),
./fs/hmfs/gc.c:inline void start_bc(struct hmfs_sb_info *sbi) {
./fs/hmfs/gc.c:		wake_up_process(sbi->gc_thread->hmfs_task);
./fs/hmfs/gc.c:void hmfs_collect_blocks(struct hmfs_sb_info *sbi)
./fs/hmfs/gc.c:	hmfs_dbg("[GC] : Start Collect Blocks # allocated blocks : %llu\n", CM_I(sbi)->alloc_block_count);
./fs/hmfs/gc.c:					hmfs_bug_on(sbi, 1);
./fs/hmfs/gc.c:		hmfs_dbg("[GC] : Collect Gabage in Segment %d\n", segno);
./fs/hmfs/gc.c:		hmfs_bug_on(sbi, write - read > allocator->buffer_index_mask);
./fs/hmfs/gc.c:	hmfs_dbg("[GC] : Finish Collect Blocks # allocated blocks : %llu\n", CM_I(sbi)->alloc_block_count);
./fs/hmfs/gc.c:	struct hmfs_sb_info *sbi = data;
./fs/hmfs/gc.c:	hmfs_dbg("[GC] : gc thread started!\n");
./fs/hmfs/gc.c:		hmfs_dbg("[GC] : befored timeout # wait_ms = %ld\n", wait_ms);
./fs/hmfs/gc.c:		hmfs_collect_blocks(sbi);
./fs/hmfs/gc.c:		if (hmfs_gc(sbi, BG_GC)) {
./fs/hmfs/gc.c:	hmfs_dbg("[GC] : gc thread stoped!");
./fs/hmfs/gc.c:int start_gc_thread(struct hmfs_sb_info *sbi)
./fs/hmfs/gc.c:	struct hmfs_kthread *gc_thread = NULL;
./fs/hmfs/gc.c:	gc_thread = kmalloc(sizeof(struct hmfs_kthread), GFP_KERNEL);
./fs/hmfs/gc.c:	gc_thread->hmfs_task = kthread_run(gc_thread_func, sbi, "hmfs_gc-%lu:->%lu",
./fs/hmfs/gc.c:	if (IS_ERR(gc_thread->hmfs_task)) {
./fs/hmfs/gc.c:		err = PTR_ERR(gc_thread->hmfs_task);
./fs/hmfs/gc.c:void stop_gc_thread(struct hmfs_sb_info *sbi)
./fs/hmfs/gc.c:		kthread_stop(sbi->gc_thread->hmfs_task);
./fs/hmfs/gc.c:int init_gc_logs(struct hmfs_sb_info *sbi)
./fs/hmfs/gc.c:	struct hmfs_checkpoint *hmfs_cp = CM_I(sbi)->last_cp_i->cp;
./fs/hmfs/gc.c:		hmfs_cp->gc_logs = cpu_to_le32(segno);
./fs/hmfs/gc.c:		hmfs_cp->nr_gc_segs = 0;
./fs/hmfs/gc.c:void reinit_gc_logs(struct hmfs_sb_info *sbi)
./fs/hmfs/gc.c:	struct hmfs_checkpoint *hmfs_cp = CM_I(sbi)->last_cp_i->cp;
./fs/hmfs/gc.c:		hmfs_cp->gc_logs = cpu_to_le32(old_segno);
./fs/hmfs/gc.c:		hmfs_cp->nr_gc_segs = 0;
./fs/hmfs/gc.c:int init_gc_stat(struct hmfs_sb_info *sbi) {
./fs/hmfs/gc.c:	struct hmfs_stat_info *si = STAT_I(sbi);
./fs/hmfs/gc.c:void destroy_gc_stat(struct hmfs_sb_info *sbi) {
./.idea/workspace.xml:      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/fs/hmfs/super.c" afterPath="$PROJECT_DIR$/fs/hmfs/super.c" />
./.idea/workspace.xml:    <favorites_list name="hmfs" />
./.idea/workspace.xml:        <entry file="file://$PROJECT_DIR$/fs/hmfs/data.c">
./.idea/workspace.xml:        <entry file="file://$PROJECT_DIR$/fs/hmfs/super.c">
./.idea/workspace.xml:        <option value="$PROJECT_DIR$/fs/hmfs/super.c" />
./.idea/workspace.xml:              <option name="myItemId" value="hmfs" />
./.idea/workspace.xml:              <option name="myItemId" value="hmfs" />
./.idea/workspace.xml:              <option name="myItemId" value="hmfs" />
./.idea/workspace.xml:              <option name="myItemId" value="hmfs" />
./.idea/workspace.xml:              <option name="myItemId" value="hmfs" />
./.idea/workspace.xml:              <option name="myItemId" value="hmfs" />
./.idea/workspace.xml:      <module name="hmfs" />
./.idea/workspace.xml:      <module name="hmfs" />
./.idea/workspace.xml:      <module name="hmfs" />
./.idea/workspace.xml:      <module name="hmfs" />
./.idea/workspace.xml:      <module name="hmfs" />
./.idea/workspace.xml:      <module name="hmfs" />
./.idea/workspace.xml:      <module name="hmfs" />
./.idea/workspace.xml:    <entry file="file://$PROJECT_DIR$/fs/hmfs/config-3.11.0+">
./.idea/workspace.xml:    <entry file="file://$PROJECT_DIR$/fs/hmfs/make.sh">
./.idea/workspace.xml:    <entry file="file://$PROJECT_DIR$/fs/hmfs/super.c">
./.idea/workspace.xml:    <entry file="file://$PROJECT_DIR$/fs/hmfs/data.c">
./.idea/modules.xml:      <module fileurl="file://$PROJECT_DIR$/.idea/hmfs.iml" filepath="$PROJECT_DIR$/.idea/hmfs.iml" />
